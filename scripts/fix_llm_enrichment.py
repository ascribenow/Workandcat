#!/usr/bin/env python3
"""
Fix Inactive Questions with Failed LLM Enrichment
Re-processes questions that are stuck in inactive state due to LLM enrichment failures
"""

import asyncio
import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# Add backend to path
sys.path.append(str(Path(__file__).parent.parent / "backend"))

from database import get_database, Question, Topic
from llm_enrichment import LLMEnrichmentPipeline
from server import enrich_question_background
from sqlalchemy import select, and_
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv(Path(__file__).parent.parent / "backend" / ".env")

async def fix_inactive_questions():
    """Find and re-process inactive questions with failed enrichment"""
    
    try:
        async for db in get_database():
            # Find inactive questions (stuck in enrichment)
            result = await db.execute(
                select(Question).where(
                    and_(
                        Question.is_active == False,
                        Question.answer.in_(["To be generated by LLM", "", None])
                    )
                )
            )
            inactive_questions = result.scalars().all()
            
            if not inactive_questions:
                logger.info("‚úÖ No inactive questions found needing enrichment")
                return
            
            logger.info(f"üîç Found {len(inactive_questions)} inactive questions needing enrichment")
            
            # Process each question
            for i, question in enumerate(inactive_questions):
                logger.info(f"üìù Processing question {i+1}/{len(inactive_questions)}: {question.id}")
                logger.info(f"   Stem: {question.stem[:100]}...")
                
                try:
                    # Call the fixed enrichment function
                    await enrich_question_background(
                        str(question.id),
                        hint_category="Arithmetic",  # Default category
                        hint_subcategory=question.subcategory or "Basic Math"
                    )
                    
                    logger.info(f"‚úÖ Successfully processed question {question.id}")
                    
                except Exception as e:
                    logger.error(f"‚ùå Failed to process question {question.id}: {e}")
                    
                    # At minimum, make the question active so it's visible
                    try:
                        await db.execute(
                            select(Question).where(Question.id == question.id)
                        )
                        question_to_update = await db.get(Question, question.id)
                        if question_to_update:
                            question_to_update.is_active = True
                            question_to_update.tags = (question_to_update.tags or []) + ["manual_activation_needed"]
                            await db.commit()
                            logger.warning(f"‚ö†Ô∏è Made question {question.id} active for manual review")
                    except Exception as commit_error:
                        logger.error(f"Failed to activate question {question.id}: {commit_error}")
            
            logger.info("üéâ Finished processing inactive questions")
            break
            
    except Exception as e:
        logger.error(f"‚ùå Error in fix_inactive_questions: {e}")
        import traceback
        traceback.print_exc()

async def check_question_quality():
    """Check the quality of existing active questions"""
    
    try:
        async for db in get_database():
            # Get all active questions
            result = await db.execute(
                select(Question).where(Question.is_active == True).limit(20)
            )
            active_questions = result.scalars().all()
            
            logger.info(f"üìä Checking quality of {len(active_questions)} active questions")
            
            placeholder_count = 0
            enriched_count = 0
            
            for question in active_questions:
                is_placeholder = (
                    question.answer in ["To be generated by LLM", "", None] or
                    question.solution_approach in ["", None] or
                    "to be determined" in (question.answer or "").lower()
                )
                
                if is_placeholder:
                    placeholder_count += 1
                    logger.warning(f"‚ö†Ô∏è Question {question.id} has placeholder content")
                else:
                    enriched_count += 1
                    logger.info(f"‚úÖ Question {question.id} is properly enriched")
            
            logger.info(f"üìà Quality Summary:")
            logger.info(f"   ‚Ä¢ Properly enriched: {enriched_count}")
            logger.info(f"   ‚Ä¢ With placeholder content: {placeholder_count}")
            logger.info(f"   ‚Ä¢ Quality rate: {(enriched_count/len(active_questions)*100):.1f}%")
            
            break
            
    except Exception as e:
        logger.error(f"‚ùå Error checking question quality: {e}")

async def main():
    """Main function to fix LLM enrichment issues"""
    logger.info("üöÄ Starting LLM Enrichment Fix Script")
    
    # Check current question quality
    await check_question_quality()
    
    # Fix inactive questions
    await fix_inactive_questions()
    
    # Check quality again
    await check_question_quality()
    
    logger.info("üéâ LLM Enrichment Fix Script completed")

if __name__ == "__main__":
    asyncio.run(main())