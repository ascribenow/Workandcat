#!/usr/bin/env python3
"""
Simple PYQ Fix Script
Uses AdvancedLLMEnrichmentService to fix placeholder text
"""

import os
import sys
import json
import asyncio
import logging
from datetime import datetime
from dotenv import load_dotenv
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker

# Add the backend directory to the Python path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def fix_single_pyq_question():
    """Fix a single PYQ question to test the approach"""
    try:
        database_url = os.getenv('DATABASE_URL')
        if not database_url:
            raise ValueError("DATABASE_URL environment variable not found")
        
        engine = create_engine(database_url)
        SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
        
        from advanced_llm_enrichment_service import AdvancedLLMEnrichmentService
        from database import PYQQuestion
        
        advanced_enricher = AdvancedLLMEnrichmentService()
        
        with SessionLocal() as db:
            # Get the first question with placeholder text
            question = db.query(PYQQuestion).filter(
                PYQQuestion.is_active == True,
                PYQQuestion.answer == 'To be generated by LLM'
            ).first()
            
            if not question:
                print("No questions found with placeholder text")
                return
            
            print(f"Processing question: {question.stem[:100]}...")
            print(f"Current answer: {question.answer}")
            print(f"Current subcategory: {question.subcategory}")
            print(f"Current type: {question.type_of_question}")
            
            # Use the deep enrichment method
            enrichment_result = await advanced_enricher.enrich_question_deeply(
                stem=question.stem,
                admin_answer=None,
                question_type="pyq"
            )
            
            if enrichment_result.get("success"):
                print("\n‚úÖ Enrichment successful!")
                
                # Update the question with the enriched data
                enrichment_data = enrichment_result.get("enrichment_data", {})
                
                # Update basic fields
                if "right_answer" in enrichment_data and enrichment_data["right_answer"]:
                    question.answer = enrichment_data["right_answer"]
                    print(f"Updated answer: {question.answer[:100]}...")
                
                if "subcategory" in enrichment_data and enrichment_data["subcategory"]:
                    question.subcategory = enrichment_data["subcategory"]
                    print(f"Updated subcategory: {question.subcategory}")
                
                if "type_of_question" in enrichment_data and enrichment_data["type_of_question"]:
                    question.type_of_question = enrichment_data["type_of_question"]
                    print(f"Updated type: {question.type_of_question}")
                
                # Update advanced fields if available
                if "core_concepts" in enrichment_data:
                    question.core_concepts = enrichment_data["core_concepts"]
                
                if "solution_method" in enrichment_data:
                    question.solution_method = enrichment_data["solution_method"]
                
                if "concept_difficulty" in enrichment_data:
                    question.concept_difficulty = enrichment_data["concept_difficulty"]
                
                if "operations_required" in enrichment_data:
                    question.operations_required = enrichment_data["operations_required"]
                
                if "problem_structure" in enrichment_data:
                    question.problem_structure = enrichment_data["problem_structure"]
                
                if "concept_keywords" in enrichment_data:
                    question.concept_keywords = enrichment_data["concept_keywords"]
                
                if "difficulty_band" in enrichment_data:
                    question.difficulty_band = enrichment_data["difficulty_band"]
                
                if "difficulty_score" in enrichment_data:
                    question.difficulty_score = enrichment_data["difficulty_score"]
                
                # Set quality verified
                question.quality_verified = True
                question.concept_extraction_status = "completed"
                
                # Save to database
                db.commit()
                
                print("\nüéâ Question successfully updated in database!")
                
                # Verify the update
                db.refresh(question)
                print(f"\nVerification:")
                print(f"Answer: {question.answer[:100]}...")
                print(f"Subcategory: {question.subcategory}")
                print(f"Type: {question.type_of_question}")
                print(f"Quality verified: {question.quality_verified}")
                
            else:
                print(f"\n‚ùå Enrichment failed: {enrichment_result.get('error', 'Unknown error')}")
            
    except Exception as e:
        logger.error(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(fix_single_pyq_question())