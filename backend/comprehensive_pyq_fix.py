#!/usr/bin/env python3
"""
Comprehensive PYQ Fix Script
Fixes placeholder text in PYQ questions with proper database handling
"""

import os
import sys
import json
import asyncio
import logging
from datetime import datetime
from dotenv import load_dotenv
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker

# Add the backend directory to the Python path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

load_dotenv()
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def comprehensive_pyq_fix():
    """Fix all PYQ questions with placeholder text"""
    try:
        database_url = os.getenv('DATABASE_URL')
        if not database_url:
            raise ValueError("DATABASE_URL environment variable not found")
        
        engine = create_engine(database_url)
        SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
        
        from advanced_llm_enrichment_service import AdvancedLLMEnrichmentService
        from database import PYQQuestion
        
        advanced_enricher = AdvancedLLMEnrichmentService()
        
        # First, count how many questions need fixing
        with SessionLocal() as db:
            incomplete_count = db.query(PYQQuestion).filter(
                PYQQuestion.is_active == True
            ).filter(
                (PYQQuestion.answer == 'To be generated by LLM') |
                (PYQQuestion.subcategory == 'To be classified by LLM') |
                (PYQQuestion.type_of_question == 'To be classified by LLM')
            ).count()
            
            print(f"üìä Found {incomplete_count} questions that need fixing")
        
        # Process in batches of 5
        batch_size = 5
        processed = 0
        successful = 0
        failed = 0
        
        while processed < min(incomplete_count, 20):  # Limit to first 20 for now
            with SessionLocal() as db:
                # Get next batch of questions
                questions = db.query(PYQQuestion).filter(
                    PYQQuestion.is_active == True
                ).filter(
                    (PYQQuestion.answer == 'To be generated by LLM') |
                    (PYQQuestion.subcategory == 'To be classified by LLM') |
                    (PYQQuestion.type_of_question == 'To be classified by LLM')
                ).limit(batch_size).all()
                
                if not questions:
                    break
                
                print(f"\nüîÑ Processing batch of {len(questions)} questions...")
                
                for i, question in enumerate(questions):
                    try:
                        print(f"\nüìù Question {processed + 1}: {question.stem[:60]}...")
                        print(f"   Current answer: {question.answer[:30]}...")
                        print(f"   Current subcategory: {question.subcategory}")
                        
                        # Perform enrichment
                        enrichment_result = await advanced_enricher.enrich_question_deeply(
                            stem=question.stem,
                            admin_answer=None,
                            question_type="pyq"
                        )
                        
                        processed += 1
                        
                        if enrichment_result.get("success"):
                            enrichment_data = enrichment_result.get("enrichment_data", {})
                            
                            # Track what we're updating
                            updates = []
                            
                            # Update answer
                            if "right_answer" in enrichment_data and enrichment_data["right_answer"]:
                                old_answer = question.answer
                                question.answer = enrichment_data["right_answer"]
                                updates.append(f"answer: '{old_answer}' ‚Üí '{question.answer[:50]}...'")
                            
                            # Update subcategory  
                            if "subcategory" in enrichment_data and enrichment_data["subcategory"]:
                                old_subcategory = question.subcategory
                                question.subcategory = enrichment_data["subcategory"]
                                updates.append(f"subcategory: '{old_subcategory}' ‚Üí '{question.subcategory}'")
                            
                            # Update type
                            if "type_of_question" in enrichment_data and enrichment_data["type_of_question"]:
                                old_type = question.type_of_question
                                question.type_of_question = enrichment_data["type_of_question"]
                                updates.append(f"type: '{old_type}' ‚Üí '{question.type_of_question}'")
                            
                            # Update advanced fields
                            advanced_updates = []
                            if "core_concepts" in enrichment_data:
                                question.core_concepts = enrichment_data["core_concepts"]
                                advanced_updates.append("core_concepts")
                            
                            if "solution_method" in enrichment_data:
                                question.solution_method = enrichment_data["solution_method"]
                                advanced_updates.append("solution_method")
                            
                            if "concept_difficulty" in enrichment_data:
                                question.concept_difficulty = enrichment_data["concept_difficulty"]
                                advanced_updates.append("concept_difficulty")
                            
                            if "operations_required" in enrichment_data:
                                question.operations_required = enrichment_data["operations_required"]
                                advanced_updates.append("operations_required")
                            
                            if "problem_structure" in enrichment_data:
                                question.problem_structure = enrichment_data["problem_structure"]
                                advanced_updates.append("problem_structure")
                            
                            if "concept_keywords" in enrichment_data:
                                question.concept_keywords = enrichment_data["concept_keywords"]
                                advanced_updates.append("concept_keywords")
                            
                            if "difficulty_band" in enrichment_data:
                                question.difficulty_band = enrichment_data["difficulty_band"]
                                advanced_updates.append("difficulty_band")
                            
                            if "difficulty_score" in enrichment_data:
                                question.difficulty_score = enrichment_data["difficulty_score"]
                                advanced_updates.append("difficulty_score")
                            
                            # Set quality flags
                            question.quality_verified = True
                            question.concept_extraction_status = "completed"
                            
                            # Commit this question
                            try:
                                db.commit()
                                successful += 1
                                print(f"   ‚úÖ Successfully updated:")
                                for update in updates:
                                    print(f"      - {update}")
                                if advanced_updates:
                                    print(f"      - Advanced fields: {', '.join(advanced_updates)}")
                            except Exception as commit_error:
                                db.rollback()
                                print(f"   ‚ùå Database commit failed: {commit_error}")
                                failed += 1
                        else:
                            failed += 1
                            error_msg = enrichment_result.get("error", "Unknown error")
                            print(f"   ‚ùå Enrichment failed: {error_msg}")
                        
                        # Small delay between questions
                        await asyncio.sleep(1)
                        
                    except Exception as e:
                        processed += 1
                        failed += 1
                        print(f"   ‚ùå Error processing question: {e}")
                        db.rollback()
        
        # Final status
        print("\n" + "="*60)
        print("COMPREHENSIVE PYQ FIX RESULTS")
        print("="*60)
        print(f"Questions Processed: {processed}")
        print(f"Successfully Fixed: {successful}")
        print(f"Failed: {failed}")
        
        if processed > 0:
            success_rate = (successful / processed) * 100
            print(f"Success Rate: {success_rate:.1f}%")
        
        print("="*60)
        
        # Check current status
        print("\nüîç Checking updated status...")
        with SessionLocal() as db:
            remaining_incomplete = db.query(PYQQuestion).filter(
                PYQQuestion.is_active == True
            ).filter(
                (PYQQuestion.answer == 'To be generated by LLM') |
                (PYQQuestion.subcategory == 'To be classified by LLM') |
                (PYQQuestion.type_of_question == 'To be classified by LLM')
            ).count()
            
            total_pyq = db.query(PYQQuestion).filter(PYQQuestion.is_active == True).count()
            
            print(f"Remaining incomplete questions: {remaining_incomplete}")
            print(f"Total PYQ questions: {total_pyq}")
            
            if total_pyq > 0:
                completion_rate = ((total_pyq - remaining_incomplete) / total_pyq) * 100
                print(f"Overall completion rate: {completion_rate:.1f}%")
            
    except Exception as e:
        logger.error(f"‚ùå Comprehensive PYQ fix failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(comprehensive_pyq_fix())