"""
CAT Preparation Platform Server v2.0 - Complete Rebuild
Comprehensive production-ready server with all advanced features
"""

from fastapi import FastAPI, APIRouter, HTTPException, UploadFile, File, Form, Depends, BackgroundTasks, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, desc, asc, func, case, text
from pydantic import BaseModel, Field, EmailStr
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta, date
from pathlib import Path
from dotenv import load_dotenv
import os
import uuid
import logging
import json
import asyncio
import random
import re
import shutil
import mimetypes
from docx import Document
import io
from google_drive_utils import GoogleDriveImageFetcher

from adaptive_session_logic import AdaptiveSessionLogic
from mcq_validation_service import mcq_validation_service
from database import (
    get_async_compatible_db, get_database, init_database, User, Question, Topic, Attempt, Mastery, Plan, PlanUnit, Session,
    PYQIngestion, PYQPaper, PYQQuestion, QuestionOption, DoubtsConversation, PrivilegedEmail, AsyncSession, SessionLocal
)
from datetime import datetime
from auth_service import AuthService, UserCreate, UserLogin, TokenResponse, require_auth, require_admin, ADMIN_EMAIL
from llm_enrichment import LLMEnrichmentPipeline, SimplifiedEnrichmentService
from advanced_llm_enrichment_service import AdvancedLLMEnrichmentService
from enhanced_enrichment_checker_service import EnhancedEnrichmentCheckerService
from background_enrichment_jobs import background_jobs
from gmail_service import gmail_service
from payment_service import (
    razorpay_service,
    CreateOrderRequest,
    PaymentVerificationRequest,
    SubscriptionRequest
)
from subscription_access_service import subscription_access_service
from mcq_generator import MCQGenerator
from study_planner import StudyPlanner
from mastery_tracker import MasteryTracker
from background_jobs import start_background_processing, stop_background_processing

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# Configuration
DATABASE_URL = os.getenv("DATABASE_URL")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Initialize enrichment services
llm_pipeline = LLMEnrichmentPipeline(OPENAI_API_KEY)
auto_enrichment_service = None  # Will be initialized when needed

def get_auto_enrichment_service():
    """Get or create the automatic enrichment service"""
    global auto_enrichment_service
    if auto_enrichment_service is None:
        from llm_enrichment import LLMEnrichmentService
        auto_enrichment_service = LLMEnrichmentService()
    return auto_enrichment_service
mcq_generator = MCQGenerator(OPENAI_API_KEY)
# enhanced_question_processor = EnhancedQuestionProcessor(llm_pipeline)  # PHASE 1: Enhanced processing - REPLACED with mcq_validation_service
study_planner = StudyPlanner()
mastery_tracker = MasteryTracker()
adaptive_session_logic = AdaptiveSessionLogic()  # Initialize sophisticated session logic

app = FastAPI(
    title="CAT Preparation Platform v2.0",
    version="2.0.0", 
    description="Complete production-ready CAT preparation platform with advanced AI features"
)

# Image upload configuration
UPLOAD_DIR = Path(__file__).parent / "uploads" / "images"
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
ALLOWED_IMAGE_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".svg"}
MAX_IMAGE_SIZE = 10 * 1024 * 1024  # 10MB

# Mount static files for serving uploaded images
app.mount("/uploads", StaticFiles(directory=str(UPLOAD_DIR.parent)), name="uploads")

api_router = APIRouter(prefix="/api")

# Pydantic Models for API

class QuestionCreateRequest(BaseModel):
    # ADMIN-PROTECTED FIELDS (never modified by LLMs)
    stem: str  # Protected: Admin-provided question text
    answer: Optional[str] = None  # Protected: Admin-provided canonical answer
    solution_approach: Optional[str] = None  # Protected: Admin-provided approach
    detailed_solution: Optional[str] = None  # Protected: Admin-provided solution
    principle_to_remember: Optional[str] = None  # Protected: Admin-provided pedagogy
    image_url: Optional[str] = None  # Protected: Admin-provided image
    
    # OPENAI-GENERATED FIELD
    right_answer: Optional[str] = None  # Generated by OpenAI based on stem
    
    # METADATA FIELDS (can be enriched by LLMs)
    hint_category: Optional[str] = None
    hint_subcategory: Optional[str] = None
    type_of_question: Optional[str] = None
    tags: List[str] = []
    source: str = "Admin"
    
    # IMAGE METADATA
    has_image: bool = False
    image_alt_text: Optional[str] = None

class SessionStart(BaseModel):
    plan_unit_ids: Optional[List[str]] = None
    target_minutes: Optional[int] = 30

class StudyPlanRequest(BaseModel):
    track: str = "Beginner"  # Default track since no diagnostic
    daily_minutes_weekday: int = 30
    daily_minutes_weekend: int = 60

class AttemptSubmission(BaseModel):
    question_id: str
    user_answer: str
    context: str = "daily"
    time_sec: Optional[int] = None
    hint_used: bool = False

# Email Authentication Models
class EmailVerificationRequest(BaseModel):
    email: EmailStr

class VerificationCodeRequest(BaseModel):
    email: EmailStr
    code: str

class PasswordResetRequest(BaseModel):
    email: EmailStr

class PasswordResetVerifyRequest(BaseModel):
    email: EmailStr
    code: str
    new_password: str

class SignupWithVerificationRequest(BaseModel):
    email: EmailStr
    password: str
    full_name: str
    code: str

class GmailAuthRequest(BaseModel):
    authorization_code: str

class EmailVerificationResponse(BaseModel):
    success: bool
    message: str
    authorization_url: Optional[str] = None

# Doubt Conversation Models
class DoubtMessage(BaseModel):
    question_id: str
    session_id: Optional[str] = None
    message: str

class DoubtResponse(BaseModel):
    success: bool
    response: Optional[str] = None
    message_count: int
    remaining_messages: int
    is_locked: bool
    error: Optional[str] = None

class DoubtConversationHistory(BaseModel):
    conversation_id: str
    messages: List[Dict[str, Any]]
    message_count: int
    remaining_messages: int
    is_locked: bool

class TriggerEnrichmentRequest(BaseModel):
    question_ids: Optional[List[str]] = None

class FeedbackSubmission(BaseModel):
    feedback: str = Field(..., min_length=1, max_length=1000)
    user_email: Optional[str] = None

# Utility Functions

def clean_solution_text(text: str) -> str:
    """Clean solution text while preserving line breaks and formatting for proper display"""
    if not text:
        return text
    
    # Preserve line breaks and proper formatting - DO NOT COLLAPSE NEWLINES
    # Only clean up excessive whitespace while preserving structure
    
    # Remove LaTeX dollar signs and other LaTeX artifacts
    cleaned = text.replace('$', '')  # Remove all dollar signs
    cleaned = cleaned.replace('\\(', '').replace('\\)', '')  # Remove LaTeX delimiters
    cleaned = cleaned.replace('\\[', '').replace('\\]', '')  # Remove LaTeX display delimiters
    
    # Remove excessive spaces (but preserve single spaces and line breaks)
    cleaned = re.sub(r'[ \t]+', ' ', cleaned)  # Only collapse horizontal whitespace
    
    # Preserve double line breaks for paragraph separation
    cleaned = re.sub(r'\n\s*\n\s*\n+', '\n\n', cleaned)  # Max 2 consecutive newlines
    
    # Remove trailing whitespace from each line but preserve line breaks
    lines = cleaned.split('\n')
    cleaned_lines = [line.rstrip() for line in lines]
    cleaned = '\n'.join(cleaned_lines)
    
    # Remove leading/trailing whitespace from entire text
    cleaned = cleaned.strip()
    
    return cleaned

async def process_question_at_upload_time(question: Question, db: AsyncSession) -> Dict[str, Any]:
    """
    Process question at upload time - generate right_answer and validate MCQ options
    """
    try:
        # Convert AsyncSession to sync session for processing
        from database import SessionLocal
        from llm_enrichment import LLMEnrichmentService
        sync_db = SessionLocal()
        
        try:
            results = {
                "right_answer_generated": False,
                "mcq_validated": False,
                "question_active": True
            }
            
            # STEP 1: Generate right_answer using OpenAI (UPLOAD TIME ONLY)
            if not question.right_answer and question.stem:
                logger.info(f"üß† Upload-time: Generating right_answer for question {question.id}")
                
                enrichment_service = LLMEnrichmentService()
                right_answer = await enrichment_service._generate_right_answer_with_openai(question.stem)
                
                if right_answer:
                    question.right_answer = right_answer
                    results["right_answer_generated"] = True
                    logger.info(f"‚úÖ Generated right_answer: {right_answer[:50]}...")
                    
                    # STEP 1.1: Cross-validate right_answer with admin's answer field
                    if question.answer:
                        validation_result = await enrichment_service._validate_answer_consistency(
                            admin_answer=question.answer,
                            ai_right_answer=right_answer,
                            question_stem=question.stem
                        )
                        
                        if not validation_result["matches"]:
                            logger.warning(f"‚ùå Upload-time answer mismatch for question {question.id}")
                            logger.warning(f"   Admin answer: {question.answer}")
                            logger.warning(f"   AI right_answer: {right_answer}")
                            
                            # Deactivate question due to answer mismatch
                            question.is_active = False
                            results["question_active"] = False
                            logger.warning("üö´ Question deactivated due to answer mismatch")
                        else:
                            logger.info(f"‚úÖ Upload-time answer validation passed")
                            question.is_active = True
            
            # STEP 2: MCQ Validation and fixing (UPLOAD TIME ONLY)
            mcq_result = await mcq_validation_service.validate_and_fix_question(question, sync_db)
            results["mcq_validated"] = mcq_result.get("action") != "error"
            
            # Save changes
            await db.commit()
            await db.refresh(question)
            
            return {
                "success": True,
                "results": results,
                "mcq_processing": mcq_result,
                "message": "Upload-time processing completed"
            }
            
        finally:
            sync_db.close()
            
    except Exception as e:
        logger.error(f"Upload-time processing failed for question {question.id}: {e}")
        return {
            "success": False,
            "error": str(e),
            "message": "Upload-time processing failed"
        }

# Core API Routes

@api_router.get("/")
async def root():
    return {
        "message": "CAT Preparation Platform v2.0",
        "admin_email": ADMIN_EMAIL,
        "features": [
            "Advanced LLM Enrichment",
            "Mastery Tracking",
            "90-Day Study Planning",
            "Real-time MCQ Generation",
            "PYQ Processing Pipeline"
        ]
    }

# Authentication Routes (from auth_service)
@api_router.post("/auth/register", response_model=TokenResponse)
async def register_user(user_data: UserCreate, db: AsyncSession = Depends(get_async_compatible_db)):
    auth_service = AuthService()
    return await auth_service.register_user_v2(user_data, db)

@api_router.post("/auth/login", response_model=TokenResponse)
async def login_user(login_data: UserLogin, db: AsyncSession = Depends(get_async_compatible_db)):
    auth_service = AuthService()
    return await auth_service.login_user_v2(login_data, db)

@api_router.get("/auth/me")
async def get_current_user_info(current_user: User = Depends(require_auth)):
    return {
        "id": str(current_user.id),
        "email": current_user.email,
        "full_name": current_user.full_name,
        "is_admin": current_user.is_admin,
        "created_at": current_user.created_at.isoformat()
    }

# Email Authentication Routes
@api_router.get("/auth/gmail/authorize")
async def get_gmail_authorization_url():
    """Get Gmail OAuth2 authorization URL"""
    try:
        auth_url = gmail_service.get_authorization_url()
        return EmailVerificationResponse(
            success=True,
            message="Gmail authorization URL generated",
            authorization_url=auth_url
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to generate authorization URL: {str(e)}")

@api_router.post("/auth/gmail/callback")
async def handle_gmail_callback(auth_request: GmailAuthRequest):
    """Handle Gmail OAuth2 callback and exchange code for tokens"""
    try:
        success = gmail_service.exchange_code_for_tokens(auth_request.authorization_code)
        if success:
            return EmailVerificationResponse(
                success=True,
                message="Gmail authentication successful"
            )
        else:
            raise HTTPException(status_code=400, detail="Failed to exchange authorization code")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Gmail authentication failed: {str(e)}")

@api_router.post("/auth/send-verification-code")
async def send_verification_code(request: EmailVerificationRequest):
    """Send verification code to email"""
    try:
        # Clean up expired codes first
        gmail_service.cleanup_expired_codes()
        
        # Authenticate Gmail service if needed
        if not gmail_service.service:
            if not gmail_service.authenticate_service():
                raise HTTPException(
                    status_code=503, 
                    detail="Email service not configured. Please contact administrator."
                )
        
        # Generate and send verification code
        code = gmail_service.generate_verification_code(request.email)
        email_sent = gmail_service.send_verification_email(request.email, code)
        
        if email_sent:
            return EmailVerificationResponse(
                success=True,
                message="Verification code sent successfully. Please check your email."
            )
        else:
            raise HTTPException(status_code=500, detail="Failed to send verification email")
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An error occurred: {str(e)}")

@api_router.post("/auth/verify-email-code")
async def verify_email_code(request: VerificationCodeRequest):
    """Verify the provided email verification code"""
    try:
        # Clean up expired codes
        gmail_service.cleanup_expired_codes()
        
        # Verify the code
        is_valid = gmail_service.verify_code(request.email, request.code)
        
        if is_valid:
            return EmailVerificationResponse(
                success=True,
                message="Email verification successful!"
            )
        else:
            raise HTTPException(
                status_code=400, 
                detail="Invalid or expired verification code"
            )
            
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An error occurred during verification: {str(e)}")

@api_router.post("/auth/signup-with-verification", response_model=TokenResponse)
async def signup_with_verification(
    request: SignupWithVerificationRequest,
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Complete signup after email verification"""
    try:
        # Verify the code first
        is_code_valid = gmail_service.verify_code(request.email, request.code)
        
        if not is_code_valid:
            raise HTTPException(
                status_code=400,
                detail="Invalid or expired verification code"
            )
        
        # Create user account
        auth_service = AuthService()
        user_create = UserCreate(
            email=request.email,
            password=request.password,
            full_name=request.full_name
        )
        
        # Register user
        token_response = await auth_service.register_user_v2(user_create, db)
        
        # Clean up verification data
        gmail_service.remove_pending_user(request.email)
        
        return token_response
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Signup failed: {str(e)}")

@api_router.post("/auth/create-verified-account", response_model=TokenResponse)
async def create_verified_account(
    request: SignupWithVerificationRequest,
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Create account for pre-verified email (email already verified via code)"""
    try:
        # Check if email was recently verified (don't re-verify code)
        # This endpoint assumes email was already verified in previous step
        
        # Create user account
        auth_service = AuthService()
        user_create = UserCreate(
            email=request.email,
            password=request.password,
            full_name=request.full_name
        )
        
        # Register user
        token_response = await auth_service.register_user_v2(user_create, db)
        
        # Clean up verification data
        gmail_service.remove_pending_user(request.email)
        
        return token_response
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Account creation failed: {str(e)}")

@api_router.post("/auth/password-reset")
async def request_password_reset(request: PasswordResetRequest, db: AsyncSession = Depends(get_async_compatible_db)):
    """Send password reset code to user's email"""
    try:
        # Check if user exists
        from sqlalchemy import select
        result = await db.execute(select(User).where(User.email == request.email))
        user = result.scalar_one_or_none()
        
        if not user:
            # Don't reveal whether email exists or not for security
            return EmailVerificationResponse(
                success=True,
                message="If an account with this email exists, a password reset code has been sent."
            )
        
        # Clean up expired codes first
        gmail_service.cleanup_expired_codes()
        
        # Authenticate Gmail service if needed
        if not gmail_service.service:
            if not gmail_service.authenticate_service():
                raise HTTPException(
                    status_code=503, 
                    detail="Email service not configured. Please contact administrator."
                )
        
        # Generate and send password reset code
        code = gmail_service.generate_verification_code(request.email)
        email_sent = gmail_service.send_password_reset_email(request.email, code)
        
        if email_sent:
            return EmailVerificationResponse(
                success=True,
                message="If an account with this email exists, a password reset code has been sent."
            )
        else:
            raise HTTPException(status_code=500, detail="Failed to send password reset email")
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An error occurred: {str(e)}")

@api_router.post("/auth/password-reset-verify")
async def verify_password_reset(
    request: PasswordResetVerifyRequest, 
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Verify password reset code and update password"""
    try:
        # Clean up expired codes
        gmail_service.cleanup_expired_codes()
        
        # Verify the code
        is_valid = gmail_service.verify_code(request.email, request.code)
        
        if not is_valid:
            raise HTTPException(
                status_code=400, 
                detail="Invalid or expired reset code"
            )
        
        # Check if user exists
        from sqlalchemy import select, update
        result = await db.execute(select(User).where(User.email == request.email))
        user = result.scalar_one_or_none()
        
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        # Update password
        auth_service = AuthService()
        hashed_password = auth_service.get_password_hash(request.new_password)
        
        await db.execute(
            update(User)
            .where(User.email == request.email)
            .values(password=hashed_password)
        )
        await db.commit()
        
        # Clean up verification data
        gmail_service.remove_pending_user(request.email)
        
        return EmailVerificationResponse(
            success=True,
            message="Password reset successfully!"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Password reset failed: {str(e)}")

@api_router.post("/auth/store-pending-user")
async def store_pending_user(
    request: dict,
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Store pending user data for later verification"""
    try:
        # This endpoint can be used to store temporary user data
        # Implementation depends on specific requirements
        return {
            "success": True,
            "message": "Pending user data stored successfully"
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to store pending user: {str(e)}")

@api_router.post("/feedback")
async def submit_feedback(feedback_data: FeedbackSubmission):
    """Submit user feedback and send email to support"""
    try:
        # Authenticate Gmail service if needed
        if not gmail_service.service:
            if not gmail_service.authenticate_service():
                raise HTTPException(
                    status_code=503, 
                    detail="Email service not available. Please try again later."
                )
        
        # Prepare email content
        subject = "New Feedback from Twelvr User"
        
        # Create email body with feedback content
        email_body = f"""
New feedback received from Twelvr:

FEEDBACK:
{feedback_data.feedback}

USER EMAIL: {feedback_data.user_email if feedback_data.user_email else 'Not provided'}

SUBMITTED AT: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC

---
This feedback was submitted through the Twelvr feedback form.
        """.strip()
        
        # Send email from hello@twelvr.com to hello@twelvr.com
        email_sent = gmail_service.send_generic_email(
            to_email="hello@twelvr.com",
            subject=subject,
            body=email_body
        )
        
        if not email_sent:
            raise HTTPException(
                status_code=500,
                detail="Failed to send feedback email. Please try again."
            )
        
        return {
            "success": True,
            "message": "Feedback submitted successfully! Thank you for helping us improve Twelvr."
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to submit feedback: {str(e)}")

# Import adaptive session engine
from adaptive_session_engine import AdaptiveSessionEngine

# Initialize adaptive engine
adaptive_engine = AdaptiveSessionEngine()

@api_router.post("/sessions/adaptive/start")
async def start_adaptive_session(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Start a new adaptive session with EWMA-based question selection"""
    try:
        # Get adaptively selected questions based on user mastery
        adaptive_questions = await adaptive_engine.get_adaptive_session_questions(
            db, str(current_user.id), target_count=15
        )
        
        if not adaptive_questions:
            raise HTTPException(status_code=404, detail="No suitable questions found for adaptive session")
        
        # Create session record
        session = Session(
            user_id=current_user.id,
            started_at=datetime.utcnow(),
            units=[q["id"] for q in adaptive_questions]  # Store question IDs
        )
        
        db.add(session)
        await db.flush()
        
        # Store session questions in a temporary way (could use Redis in production)
        session_questions = {
            str(session.id): {
                "questions": adaptive_questions,
                "current_index": 0,
                "total_questions": len(adaptive_questions),
                "user_id": str(current_user.id)
            }
        }
        
        # In a real system, this would be stored in Redis or session storage
        # For now, we'll get the first question immediately
        first_question = adaptive_questions[0]
        
        await db.commit()
        
        return {
            "session_id": str(session.id),
            "total_questions": len(adaptive_questions),
            "first_question": {
                "id": first_question["id"],
                "topic_name": first_question["topic_name"],
                "subcategory": first_question["subcategory"],
                "difficulty_band": first_question["difficulty_band"],
                "mastery_category": first_question["mastery_category"],
                "adaptive_score": first_question["adaptive_score"]
            },
            "adaptive_info": {
                "session_type": "adaptive",
                "based_on_mastery": True,
                "selection_algorithm": "EWMA-based"
            },
            "message": "Adaptive session started with mastery-based question selection"
        }
        
    except Exception as e:
        logger.error(f"Error starting adaptive session: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@api_router.get("/sessions/adaptive/{session_id}/next")
async def get_next_adaptive_question(
    session_id: str,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get next question in adaptive session with full question data"""
    try:
        # Get session
        session_result = await db.execute(
            select(Session).where(Session.id == session_id, Session.user_id == current_user.id)
        )
        session = session_result.scalar_one_or_none()
        
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        # Get adaptive questions again (in production, this would be cached)
        adaptive_questions = await adaptive_engine.get_adaptive_session_questions(
            db, str(current_user.id), target_count=15
        )
        
        if not adaptive_questions:
            return {"question": None, "session_complete": True}
        
        # For simplicity, return a random question from adaptive set
        # In production, you'd track session progress
        question_data = random.choice(adaptive_questions)
        
        # Get full question details
        question_result = await db.execute(
            select(Question).where(Question.id == question_data["id"])
        )
        question = question_result.scalar_one_or_none()
        
        if not question:
            raise HTTPException(status_code=404, detail="Question not found")
        
        return {
            "question": {
                "id": str(question.id),
                "stem": question.stem,
                "subcategory": question.subcategory,
                "difficulty_band": question.difficulty_band,
                "type_of_question": question.type_of_question,
                "answer": clean_solution_text(question.answer) if question.answer else None
            },
            "adaptive_info": {
                "mastery_score": question_data["mastery_score"],
                "mastery_category": question_data["mastery_category"],
                "adaptive_score": question_data["adaptive_score"],
                "topic_name": question_data["topic_name"],
                "selection_reason": f"Selected for {question_data['mastery_category']} mastery level"
            },
            "session_complete": False
        }
        
    except Exception as e:
        logger.error(f"Error getting next adaptive question: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Question Answer Submission

@api_router.post("/submit-answer")
async def submit_answer(
    attempt_data: AttemptSubmission,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Submit answer for a question"""
    try:
        # Get question to check correct answer
        result = await db.execute(select(Question).where(Question.id == attempt_data.question_id))
        question = result.scalar_one_or_none()
        
        if not question:
            raise HTTPException(status_code=404, detail="Question not found")
        
        # Check if answer is correct
        is_correct = attempt_data.user_answer.strip().lower() == question.answer.strip().lower()
        
        # Create attempt record
        attempt = Attempt(
            user_id=current_user.id,
            question_id=attempt_data.question_id,
            attempt_no=1,  # Simple submission
            context=attempt_data.context,
            options={},  # Would store the actual options shown
            user_answer=attempt_data.user_answer,
            correct=is_correct,
            time_sec=attempt_data.time_sec or 0,
            hint_used=attempt_data.hint_used
        )
        
        db.add(attempt)
        await db.commit()
        
        # Update mastery tracking (both topic-level and type-level)
        await mastery_tracker.update_mastery_after_attempt(db, attempt)
        await mastery_tracker.update_type_mastery_after_attempt(db, attempt)  # New type-level tracking
        
        # Return feedback
        return {
            "correct": is_correct,
            "message": "Answer submitted successfully",
            "attempt_id": str(attempt.id),
            "solution_feedback": {
                "solution_approach": clean_solution_text(question.solution_approach) or "Solution approach not available",
                "detailed_solution": clean_solution_text(question.detailed_solution) or "Detailed solution not available",
                "principle_to_remember": clean_solution_text(question.principle_to_remember) or "Principle not available"
            } if not is_correct else None
        }
        
    except Exception as e:
        logger.error(f"Error submitting answer: {e}")
        raise HTTPException(status_code=500, detail="Error submitting answer")

@app.get("/api/mastery/type-breakdown")
async def get_type_mastery_breakdown(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get detailed type-level mastery breakdown for enhanced dashboard"""
    try:
        logger.info(f"Fetching type mastery breakdown for user {current_user.id}")
        
        # Get type-level mastery breakdown
        type_breakdown = await mastery_tracker.get_type_mastery_breakdown(db, current_user.id)
        
        # Calculate summary statistics
        total_types = len(type_breakdown)
        mastered_types = sum(1 for item in type_breakdown if item['mastery_percentage'] >= 80)
        weak_types = sum(1 for item in type_breakdown if item['mastery_percentage'] < 60)
        total_attempts = sum(item['total_attempts'] for item in type_breakdown)
        
        # Group by category for dashboard display
        category_summaries = {}
        for item in type_breakdown:
            category = item['category']
            if category not in category_summaries:
                category_summaries[category] = {
                    'category': category,
                    'total_types': 0,
                    'mastered_types': 0,
                    'weak_types': 0,
                    'avg_mastery': 0,
                    'types': []
                }
            
            category_summaries[category]['total_types'] += 1
            category_summaries[category]['types'].append(item)
            
            if item['mastery_percentage'] >= 80:
                category_summaries[category]['mastered_types'] += 1
            if item['mastery_percentage'] < 60:
                category_summaries[category]['weak_types'] += 1
        
        # Calculate average mastery per category
        for category_data in category_summaries.values():
            if category_data['types']:
                category_data['avg_mastery'] = sum(t['mastery_percentage'] for t in category_data['types']) / len(category_data['types'])
        
        response = {
            "type_breakdown": type_breakdown,
            "summary": {
                "total_types": total_types,
                "mastered_types": mastered_types,  
                "weak_types": weak_types,
                "total_attempts": total_attempts,
                "overall_mastery": sum(item['mastery_percentage'] for item in type_breakdown) / total_types if total_types > 0 else 0
            },
            "category_summaries": list(category_summaries.values())
        }
        
        logger.info(f"Retrieved type mastery breakdown: {total_types} types, {mastered_types} mastered, {weak_types} weak")
        return response
        
    except Exception as e:
        logger.error(f"Error getting type mastery breakdown: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving type mastery data")

@api_router.post("/admin/init-topics")
async def init_basic_topics(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Initialize basic topics for testing"""
    try:
        # Check if topics already exist
        result = await db.execute(select(Topic).limit(1))
        existing_topic = result.scalar_one_or_none()
        
        if existing_topic:
            return {"message": "Topics already exist", "count": "existing"}
        
        # Create basic topics
        topics = [
            Topic(
                name="Arithmetic",
                slug="arithmetic",
                category="A",
                centrality=0.8
            ),
            Topic(
                name="Speed-Time-Distance",
                slug="speed-time-distance", 
                category="A",
                centrality=0.7
            ),
            Topic(
                name="General",
                slug="general",
                category="A", 
                centrality=0.5
            )
        ]
        
        for topic in topics:
            db.add(topic)
        
        await db.commit()
        
        return {
            "message": "Basic topics created successfully",
            "topics_created": len(topics),
            "topics": [{"name": t.name, "category": t.category} for t in topics]
        }
        
    except Exception as e:
        logger.error(f"Error initializing topics: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ===========================================
# PAYMENT ENDPOINTS
# ===========================================

@api_router.post("/payments/create-order")
async def create_payment_order(order_request: CreateOrderRequest, current_user: User = Depends(require_auth)):
    """Create Razorpay order for one-time payments (Pro Regular)"""
    try:
        user_id = str(current_user.id)
        
        if order_request.plan_type not in ["pro_regular", "pro_exclusive"]:
            raise HTTPException(status_code=400, detail="Invalid plan type")
        
        # For Pro Regular, redirect to subscription
        if order_request.plan_type == "pro_regular":
            raise HTTPException(
                status_code=400, 
                detail="Pro Regular requires subscription. Use /api/payments/create-subscription endpoint"
            )
        
        order = await razorpay_service.create_order(
            plan_type=order_request.plan_type,
            user_email=order_request.user_email,
            user_name=order_request.user_name,
            user_id=user_id,
            user_phone=order_request.user_phone
        )
        
        # Add payment methods configuration
        payment_config = razorpay_service.get_payment_methods_config()
        order.update({
            "key": os.getenv("RAZORPAY_KEY_ID"),
            "payment_methods": payment_config["methods"],
            "theme": payment_config["theme"],
            "modal": payment_config["modal"]
        })
        
        return {"success": True, "data": order}
        
    except Exception as e:
        logger.error(f"Error creating payment order: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/payments/create-subscription")
async def create_subscription(sub_request: SubscriptionRequest, current_user: User = Depends(require_auth)):
    """Create Razorpay subscription for Pro Lite with auto-renewal"""
    try:
        user_id = str(current_user.id)
        
        if sub_request.plan_type != "pro_regular":
            raise HTTPException(status_code=400, detail="Subscriptions are only available for Pro Regular")
        
        subscription = await razorpay_service.create_subscription(
            plan_type=sub_request.plan_type,
            user_email=sub_request.user_email,
            user_name=sub_request.user_name,
            user_id=user_id,
            user_phone=sub_request.user_phone
        )
        
        return {"success": True, "data": subscription}
        
    except Exception as e:
        logger.error(f"Error creating subscription: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/payments/verify-payment")
async def verify_payment(verification_request: PaymentVerificationRequest, current_user: User = Depends(require_auth)):
    """Verify Razorpay payment and activate subscription"""
    try:
        user_id = str(current_user.id)
        
        if verification_request.user_id != user_id:
            raise HTTPException(status_code=403, detail="User ID mismatch")
        
        result = await razorpay_service.verify_payment(
            order_id=verification_request.razorpay_order_id,
            payment_id=verification_request.razorpay_payment_id,
            signature=verification_request.razorpay_signature,
            user_id=user_id
        )
        
        return {"success": True, "data": result}
        
    except Exception as e:
        logger.error(f"Payment verification failed: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))

@api_router.get("/payments/subscription-status")
async def get_subscription_status(current_user: User = Depends(require_auth)):
    """Get user's current subscription status"""
    try:
        user_id = str(current_user.id)
        subscriptions = await razorpay_service.get_user_subscriptions(user_id)
        
        return {"success": True, "subscriptions": subscriptions}
        
    except Exception as e:
        logger.error(f"Error fetching subscription status: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/payments/cancel-subscription/{subscription_id}")
async def cancel_subscription(subscription_id: str, current_user: User = Depends(require_auth)):
    """Cancel user's subscription"""
    try:
        user_id = str(current_user.id)
        result = await razorpay_service.cancel_subscription(user_id, subscription_id)
        
        return {"success": True, "data": result}
        
    except Exception as e:
        logger.error(f"Error cancelling subscription: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.get("/payments/config")
async def get_payment_config():
    """Get Razorpay configuration for frontend"""
    try:
        config = razorpay_service.get_payment_methods_config()
        return {
            "success": True,
            "key_id": os.getenv("RAZORPAY_KEY_ID"),
            "config": config
        }
        
    except Exception as e:
        logger.error(f"Error fetching payment config: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/payments/webhook")
async def razorpay_webhook(request: Request):
    """Handle Razorpay webhook notifications"""
    try:
        payload = await request.body()
        signature = request.headers.get('X-Razorpay-Signature', '')
        
        # Verify webhook signature (implement as needed)
        # razorpay_service.client.utility.verify_webhook_signature(
        #     payload.decode(),
        #     signature,
        #     os.getenv('RAZORPAY_WEBHOOK_SECRET')
        # )
        
        # Process webhook event (subscription updates, payment failures, etc.)
        logger.info(f"Received webhook: {payload}")
        
        return {"status": "processed"}
        
    except Exception as e:
        logger.error(f"Webhook processing failed: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))

# ===========================================
# END PAYMENT ENDPOINTS
# ===========================================

@api_router.post("/questions")
async def create_question(
    question_data: QuestionCreateRequest,
    background_tasks: BackgroundTasks,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Create a new question with LLM enrichment"""
    try:
        # Find the appropriate topic for this question
        subcategory = question_data.hint_subcategory or "Time‚ÄìSpeed‚ÄìDistance (TSD)"
        topic_result = await db.execute(
            select(Topic).where(Topic.name == subcategory)
        )
        topic = topic_result.scalar_one_or_none()
        
        if not topic:
            # If subcategory topic not found, try to find by parent category
            category = question_data.hint_category or "Arithmetic"
            topic_result = await db.execute(
                select(Topic).where(Topic.name == category, Topic.parent_id.is_(None))
            )
            parent_topic = topic_result.scalar_one_or_none()
            
            if parent_topic:
                topic = parent_topic
            else:
                raise HTTPException(status_code=400, detail=f"Topic not found for category: {category}, subcategory: {subcategory}")
        
        # Create basic question first including image fields
        question = Question(
            topic_id=topic.id,  # Set the topic_id
            subcategory=subcategory,
            type_of_question=question_data.type_of_question or '',
            stem=question_data.stem,
            answer=question_data.answer or "To be generated by LLM",  # Default if not provided
            right_answer=question_data.right_answer,  # NEW: Right answer field
            solution_approach=question_data.solution_approach or "",
            detailed_solution=question_data.detailed_solution or "",
            principle_to_remember=question_data.principle_to_remember or "",  # NEW: Store pedagogy field verbatim
            tags=json.dumps(question_data.tags) if question_data.tags else '[]',
            source=question_data.source,
            # Auto-set has_image based on successful image download
            has_image=bool(question_data.image_url and question_data.image_url.strip()),
            image_url=question_data.image_url,
            image_alt_text=question_data.image_alt_text,
            is_active=True if question_data.source == "Test Data" else False  # Activate test questions immediately
        )
        
        db.add(question)
        await db.commit()
        
        # UPLOAD-TIME PROCESSING: Generate right_answer and validate MCQ options
        await db.refresh(question)
        upload_processing_result = await process_question_at_upload_time(question, db)
        
        # Queue enrichment as background task (metadata only)
        background_tasks.add_task(
            enrich_question_background,
            str(question.id),
            question_data.hint_category,
            question_data.hint_subcategory
        )
        
        return {
            "message": "Question created and processed",
            "question_id": str(question.id),
            "status": "processed" if upload_processing_result["success"] else "processing_partial",
            "upload_processing": upload_processing_result
        }
        
    except Exception as e:
        logger.error(f"Error creating question: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.get("/questions")
async def get_questions(
    category: Optional[str] = None,
    subcategory: Optional[str] = None,
    difficulty: Optional[str] = None,
    limit: int = 50,
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get questions with filtering"""
    try:
        query = select(Question)  # Remove is_active filter for testing
        
        if category:
            query = query.join(Question.topic).where(Topic.name == category)
        if subcategory:
            query = query.where(Question.subcategory == subcategory)
        if difficulty:
            query = query.where(Question.difficulty_band == difficulty)
        
        query = query.limit(limit).order_by(desc(Question.importance_index))
        
        result = await db.execute(query)
        questions = result.scalars().all()
        
        questions_data = []
        for q in questions:
            questions_data.append({
                "id": str(q.id),
                "stem": q.stem,
                "answer": q.answer,
                "solution_approach": q.solution_approach,
                "detailed_solution": q.detailed_solution,
                "subcategory": q.subcategory,
                "type_of_question": q.type_of_question,  # Add Type field for taxonomy triple
                "difficulty_band": q.difficulty_band,
                "difficulty_score": float(q.difficulty_score) if q.difficulty_score else None,
                "importance_index": float(q.importance_index) if q.importance_index else None,
                "learning_impact": float(q.learning_impact) if q.learning_impact else None,
                "pyq_frequency_score": float(q.pyq_frequency_score) if q.pyq_frequency_score else None,
                "is_active": q.is_active,
                # NEW: Include LLM-generated fields for 100% success validation
                "category": q.category,  # Main category field
                "right_answer": q.right_answer,  # LLM-generated right answer
                "frequency_analysis_method": q.frequency_analysis_method,  # Dynamic frequency method
                "pyq_conceptual_matches": q.pyq_conceptual_matches,  # Conceptual matching count
                # Image support fields
                "has_image": q.has_image,
                "image_url": q.image_url,
                "image_alt_text": q.image_alt_text,
                "created_at": q.created_at.isoformat()
            })
        
        return {"questions": questions_data}
        
    except Exception as e:
        logger.error(f"Error getting questions: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Study Planning Routes

@api_router.post("/study-plan")
async def create_study_plan(
    plan_request: StudyPlanRequest,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Create personalized 90-day study plan"""
    try:
        # Use the provided track or default to Beginner
        track = plan_request.track or "Beginner"
        
        # Create plan
        plan = await study_planner.create_plan(
            db,
            str(current_user.id),
            track,
            plan_request.daily_minutes_weekday,
            plan_request.daily_minutes_weekend
        )
        
        return {
            "message": "Study plan created successfully",
            "plan_id": str(plan.id),
            "track": plan.track,
            "start_date": plan.start_date.isoformat(),
            "daily_minutes_weekday": plan.daily_minutes_weekday,
            "daily_minutes_weekend": plan.daily_minutes_weekend
        }
        
    except Exception as e:
        logger.error(f"Error creating study plan: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.get("/study-plan/today")
async def get_today_plan(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get today's study plan units"""
    try:
        today = date.today()
        
        # Get active plan for user
        plan_result = await db.execute(
            select(Plan)
            .where(
                Plan.user_id == current_user.id,
                Plan.status == "active"
            )
            .order_by(desc(Plan.created_at))
            .limit(1)
        )
        plan = plan_result.scalar_one_or_none()
        
        if not plan:
            return {"plan_units": [], "message": "No active study plan found"}
        
        # Get plan units for today
        units_result = await db.execute(
            select(PlanUnit)
            .where(
                PlanUnit.plan_id == plan.id,
                PlanUnit.planned_for == today
            )
            .order_by(PlanUnit.created_at)
        )
        units = units_result.scalars().all()
        
        units_data = []
        for unit in units:
            units_data.append({
                "id": str(unit.id),
                "unit_kind": unit.unit_kind,
                "target_count": unit.target_count,
                "status": unit.status,
                "topic_id": str(unit.topic_id),
                "generated_payload": unit.generated_payload
            })
        
        return {"plan_units": units_data, "date": today.isoformat()}
        
    except Exception as e:
        logger.error(f"Error getting today's plan: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/sessions/report-broken-image")
async def report_broken_image(
    request: dict,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Report a question with broken image to block it from future sessions"""
    try:
        question_id = request.get('question_id')
        if not question_id:
            raise HTTPException(status_code=400, detail="Missing question_id")
        
        # Get the question
        result = await db.execute(select(Question).where(Question.id == question_id))
        question = result.scalar_one_or_none()
        
        if not question:
            raise HTTPException(status_code=404, detail="Question not found")
        
        # Mark question as inactive due to broken image
        question.is_active = False
        
        # Add tag to indicate image issue
        current_tags = question.tags or []
        if "broken_image" not in current_tags:
            current_tags.append("broken_image")
            current_tags.append("needs_image_fix")
            question.tags = current_tags
        
        await db.commit()
        
        logger.warning(f"Question {question_id} marked as inactive due to broken image by user {current_user.email}")
        
        return {
            "message": "Question blocked from future sessions due to broken image",
            "question_id": question_id,
            "status": "blocked"
        }
        
    except Exception as e:
        logger.error(f"Error reporting broken image: {e}")
        raise HTTPException(status_code=500, detail="Failed to report broken image")

# Session Management Routes

@api_router.get("/sessions/current-status")
async def get_current_session_status(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Check if user has an active session for today that can be resumed"""
    try:
        # Get the most recent session for today
        today_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
        
        session_result = await db.execute(
            select(Session)
            .where(
                Session.user_id == current_user.id,
                Session.started_at >= today_start
            )
            .order_by(Session.started_at.desc())
            .limit(1)
        )
        session = session_result.scalar_one_or_none()
        
        if not session:
            return {
                "active_session": False,
                "message": "No active session found for today"
            }
        
        # Parse question IDs from session
        try:
            question_ids = json.loads(session.units) if session.units else []
        except (json.JSONDecodeError, TypeError):
            return {
                "active_session": False,
                "message": "Invalid session data"
            }
        
        if not question_ids:
            return {
                "active_session": False,
                "message": "Session has no questions"
            }
        
        # Count how many questions have been attempted in this session
        attempts_result = await db.execute(
            select(func.count(Attempt.id))
            .where(
                Attempt.user_id == current_user.id,
                Attempt.question_id.in_(question_ids),
                Attempt.created_at >= session.started_at
            )
        )
        answered_count = attempts_result.scalar() or 0
        total_questions = len(question_ids)
        
        # If session is complete, no active session
        if answered_count >= total_questions:
            return {
                "active_session": False,
                "message": "Today's session already completed"
            }
        
        # Session can be resumed
        return {
            "active_session": True,
            "session_id": str(session.id),
            "progress": {
                "answered": answered_count,
                "total": total_questions,
                "next_question": answered_count + 1
            },
            "message": f"Resuming session - Question {answered_count + 1} of {total_questions}"
        }
        
    except Exception as e:
        logger.error(f"Error checking session status: {e}")
        return {
            "active_session": False,
            "message": "Error checking session status"
        }

@api_router.post("/sessions/start")
async def start_session(
    session_data: SessionStart,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Start a sophisticated 12-question session with personalized question selection"""
    try:
        logger.info(f"Starting sophisticated session for user {current_user.id}")
        
        # Use adaptive session logic for sophisticated dual-dimension diversity enforcement
        # FIXED: Use direct SessionLocal() instead of generator
        from database import SessionLocal
        sync_db = SessionLocal()
        try:
            session_result = adaptive_session_logic.create_personalized_session(
                current_user.id, sync_db
            )
        finally:
            sync_db.close()
        
        questions = session_result["questions"]
        metadata = session_result["metadata"]
        personalized = session_result["personalization_applied"]
        phase_info = session_result.get("phase_info", {})  # Extract phase_info from session_result
        
        if not questions:
            raise HTTPException(status_code=404, detail="No questions available for session")
        
        question_count = len(questions)
        
        # Create session record with question IDs as JSON string
        question_ids = [str(q.id) for q in questions]
        session = Session(
            user_id=current_user.id,
            started_at=datetime.utcnow(),
            units=json.dumps(question_ids),  # Store as JSON string for SQLite
            notes=f"{'Personalized' if personalized else 'Standard'} 12-question session - Stage: {metadata.get('learning_stage', 'N/A')} - Accuracy: {metadata.get('recent_accuracy', 0):.1f}%"
        )
        
        db.add(session)
        await db.commit()
        
        # Enhanced response with session intelligence and questions for validation
        response = {
            "message": f"{'üéØ Personalized' if personalized else 'üìö Standard'} 12-question session started successfully",
            "session_id": str(session.id),
            "total_questions": question_count,
            "session_type": "intelligent_12_question_set",
            "current_question": 1,
            "questions": [
                {
                    "id": str(q.id),
                    "stem": q.stem,
                    "answer": q.answer,
                    "solution_approach": q.solution_approach,
                    "detailed_solution": q.detailed_solution,
                    "subcategory": q.subcategory,
                    "type_of_question": q.type_of_question,
                    "difficulty_band": q.difficulty_band,
                    "difficulty_score": float(q.difficulty_score) if q.difficulty_score else None,
                    "pyq_frequency_score": float(q.pyq_frequency_score) if q.pyq_frequency_score else None,
                    "has_image": q.has_image,
                    "image_url": q.image_url,
                    "image_alt_text": q.image_alt_text,
                    "created_at": q.created_at.isoformat()
                } for q in questions
            ],
            "metadata": metadata,  # Include dual-dimension diversity metadata
            "phase_info": phase_info,  # Include three-phase adaptive information
            "personalization": {
                "applied": personalized,
                "learning_stage": metadata.get('learning_stage', 'unknown'),
                "recent_accuracy": metadata.get('recent_accuracy', 0),
                "difficulty_distribution": metadata.get('difficulty_distribution', {}),
                "category_distribution": metadata.get('category_distribution', {}),
                "subcategory_distribution": metadata.get('subcategory_distribution', {}),
                "type_distribution": metadata.get('type_distribution', {}),
                "dual_dimension_diversity": metadata.get('dual_dimension_diversity', 0),
                "subcategory_caps_analysis": metadata.get('subcategory_caps_analysis', {}),
                "type_within_subcategory_analysis": metadata.get('type_within_subcategory_analysis', {}),
                "weak_areas_targeted": metadata.get('weak_areas_targeted', 0)
            }
        }
        
        logger.info(f"Session created successfully: {session.id} - Personalized: {personalized}")
        return response
        
    except Exception as e:
        logger.error(f"Error starting sophisticated session: {e}")
        # Fallback to simple session if sophisticated logic fails
        try:
            # Simple fallback: get any 12 active questions
            fallback_result = await db.execute(
                select(Question)
                .where(Question.is_active == True)
                .order_by(func.random())
                .limit(12)
            )
            questions = fallback_result.scalars().all()
            
            if not questions:
                raise HTTPException(status_code=404, detail="No questions available")
            
            question_ids = [str(q.id) for q in questions]
            session = Session(
                user_id=current_user.id,
                started_at=datetime.utcnow(),
                units=json.dumps(question_ids),
                notes="Fallback 12-question session"
            )
            
            db.add(session)
            await db.commit()
            
            return {
                "message": "üìö Standard 12-question session started (fallback mode)",
                "session_id": str(session.id),
                "total_questions": len(questions),
                "session_type": "fallback_12_question_set",
                "current_question": 1,
                "personalization": {
                    "applied": False,
                    "learning_stage": "unknown",
                    "recent_accuracy": 0,
                    "difficulty_distribution": {},
                    "category_distribution": {},
                    "weak_areas_targeted": 0
                }
            }
            
        except Exception as fallback_error:
            logger.error(f"Fallback session creation also failed: {fallback_error}")
            raise HTTPException(status_code=500, detail="Unable to create session")

@api_router.get("/sessions/{session_id}/next-question")
async def get_next_question(
    session_id: str,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get next question for the 12-question session"""
    try:
        # Get session
        session_result = await db.execute(
            select(Session).where(Session.id == session_id, Session.user_id == current_user.id)
        )
        session = session_result.scalar_one_or_none()
        
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        # Parse question IDs from JSON string
        try:
            import json
            question_ids = json.loads(session.units) if session.units else []
        except (json.JSONDecodeError, TypeError):
            raise HTTPException(status_code=500, detail="Invalid session data")
        
        if not question_ids:
            raise HTTPException(status_code=404, detail="No questions in this session")
        
        # Get number of attempts in this session to determine current question
        attempts_result = await db.execute(
            select(func.count(Attempt.id))
            .where(
                Attempt.user_id == current_user.id,
                Attempt.question_id.in_(question_ids),
                Attempt.created_at >= session.started_at
            )
        )
        answered_count = attempts_result.scalar() or 0
        
        # Check if session is complete
        if answered_count >= len(question_ids):
            return {
                "session_complete": True,
                "message": "All questions completed!",
                "questions_completed": answered_count,
                "total_questions": len(question_ids)
            }
        
        # Get the next unanswered question
        current_question_id = question_ids[answered_count]
        
        # Get question details
        question_result = await db.execute(
            select(Question).where(Question.id == current_question_id)
        )
        question = question_result.scalar_one_or_none()
        
        if not question:
            raise HTTPException(status_code=404, detail="Question not found")
        
        # Use stored MCQ options first, then generate if needed
        options = None
        
        # First, try to use pre-stored MCQ options from enrichment
        if question.mcq_options:
            try:
                import json
                options = json.loads(question.mcq_options)
                logger.info(f"Using stored MCQ options for question {question.id}")
            except Exception as json_error:
                logger.warning(f"Failed to parse stored MCQ options: {json_error}")
        
        # If no stored options, generate new ones
        if not options:
            try:
                logger.info(f"Generating new MCQ options for question {question.id}")
                options = await mcq_generator.generate_options(
                    question.stem, 
                    question.subcategory, 
                    question.difficulty_band or "Medium", 
                    question.answer
                )
            except Exception as mcq_error:
                logger.warning(f"MCQ generation failed for question {question.id}: {mcq_error}")
                # Enhanced fallback with meaningful mathematical options
                import random
                import re
                
                # Extract numbers from question for context-aware options
                numbers = re.findall(r'\d+\.?\d*', question.stem)
                question_stem = question.stem.lower()
                
                # Determine question type and generate appropriate options
                if 'factor' in question_stem and numbers:
                    # Factors question - generate factor-based options
                    base_num = int(float(numbers[0])) if numbers else 8
                    options = {
                        "A": str(base_num + 2),
                        "B": str(base_num * 2),
                        "C": str(base_num + 4), 
                        "D": str(base_num * 3),
                        "correct": "B"
                    }
                elif 'time' in question_stem or 'speed' in question_stem:
                    # Time-speed-distance question
                    options = {
                        "A": "2 hours",
                        "B": "3 hours",
                        "C": "4 hours",
                        "D": "5 hours", 
                        "correct": "C"
                    }
                elif 'percentage' in question_stem or '%' in question.stem:
                    # Percentage question
                    options = {
                        "A": "25%",
                        "B": "50%", 
                        "C": "75%",
                        "D": "100%",
                        "correct": "B"
                    }
                elif any(word in question_stem for word in ['area', 'volume', 'perimeter']):
                    # Geometry question
                    base = int(float(numbers[0])) if numbers else 20
                    options = {
                        "A": f"{base} sq units",
                        "B": f"{base * 2} sq units",
                        "C": f"{base * 3} sq units", 
                        "D": f"{base * 4} sq units",
                        "correct": "C"
                    }
                elif numbers and len(numbers) >= 2:
                    # General numerical question - use extracted numbers
                    num1, num2 = float(numbers[0]), float(numbers[1])
                    result = int(num1 + num2)
                    options = {
                        "A": str(result - 5),
                        "B": str(result),
                        "C": str(result + 10),
                        "D": str(result * 2),
                        "correct": "B"
                    }
                else:
                    # Default mathematical options
                    options = {
                        "A": "12",
                        "B": "18",
                        "C": "24", 
                        "D": "36",
                        "correct": "C"
                    }
                
                logger.info(f"Generated contextual fallback options for question type: {question.stem[:50]}...")
        
        return {
            "question": {
                "id": str(question.id),
                "stem": question.stem,
                "subcategory": question.subcategory,
                "difficulty_band": question.difficulty_band,
                "type_of_question": question.type_of_question,
                "has_image": question.has_image,
                "image_url": question.image_url,
                "image_alt_text": question.image_alt_text,
                "options": options,
                # Include solutions (with cleaned formatting and fallback when enrichment is missing)
                "answer": clean_solution_text(question.answer) or options.get("A", "Answer not available"),
                "solution_approach": clean_solution_text(question.solution_approach) or "Solution approach will be provided after enrichment",
                "detailed_solution": clean_solution_text(question.detailed_solution) or "Detailed solution will be provided after enrichment"
            },
            "session_progress": {
                "current_question": answered_count + 1,
                "total_questions": len(question_ids),
                "questions_remaining": len(question_ids) - answered_count,
                "progress_percentage": round((answered_count + 1) / len(question_ids) * 100, 1)
            },
            "session_intelligence": {
                "question_selected_for": "Based on your learning profile and performance patterns",
                "difficulty_rationale": f"This {question.difficulty_band or 'Medium'} question is chosen to match your current skill level",
                "category_focus": f"Focusing on {question.subcategory} to strengthen your understanding"
            },
            "session_complete": False
        }
        
    except Exception as e:
        logger.error(f"Error getting next question: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/sessions/{session_id}/submit-answer")
async def submit_session_answer(
    session_id: str,
    attempt_data: AttemptSubmission,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Submit answer during study session with comprehensive solution feedback"""
    try:
        # Get session
        session_result = await db.execute(
            select(Session).where(Session.id == session_id, Session.user_id == current_user.id)
        )
        session = session_result.scalar_one_or_none()
        
        if not session:
            raise HTTPException(status_code=404, detail="Session not found")
        
        # Get question to check correct answer
        result = await db.execute(select(Question).where(Question.id == attempt_data.question_id))
        question = result.scalar_one_or_none()
        
        if not question:
            raise HTTPException(status_code=404, detail="Question not found")
        
        # Check if answer is correct (case-insensitive comparison)
        user_answer_clean = attempt_data.user_answer.strip().lower()
        correct_answer_clean = question.answer.strip().lower()
        is_correct = user_answer_clean == correct_answer_clean
        
        # Get current attempt number for this question
        attempts_count_result = await db.execute(
            select(func.count(Attempt.id))
            .where(Attempt.user_id == current_user.id, Attempt.question_id == attempt_data.question_id)
        )
        attempt_number = (attempts_count_result.scalar() or 0) + 1
        
        # Create attempt record
        attempt = Attempt(
            user_id=current_user.id,
            question_id=attempt_data.question_id,
            attempt_no=attempt_number,
            context="session",
            options={},  # Store the actual options shown if needed
            user_answer=attempt_data.user_answer,
            correct=is_correct,
            time_sec=attempt_data.time_sec or 0,
            hint_used=attempt_data.hint_used
        )
        
        db.add(attempt)
        await db.commit()
        
        # Update mastery tracking
        try:
            await mastery_tracker.update_mastery_after_attempt(db, attempt)
        except Exception as e:
            logger.warning(f"Mastery update failed: {e}")
        
        # Check if session is now complete (all questions answered)
        try:
            question_ids = json.loads(session.units) if session.units else []
        except (json.JSONDecodeError, TypeError):
            question_ids = []
        
        if question_ids:
            session_attempts_result = await db.execute(
                select(func.count(Attempt.id.distinct()))
                .where(
                    Attempt.user_id == current_user.id,
                    Attempt.question_id.in_(question_ids),
                    Attempt.created_at >= session.started_at
                )
            )
            answered_session_questions = session_attempts_result.scalar() or 0
            total_session_questions = len(question_ids)
            
            # Mark session as complete if all questions answered
            if answered_session_questions >= total_session_questions and not session.ended_at:
                from datetime import datetime
                session.ended_at = datetime.utcnow()
                await db.commit()
                logger.info(f"Session {session_id} marked as complete for user {current_user.id}")
        
        # Always return comprehensive feedback with solution
        return {
            "correct": is_correct,
            "status": "correct" if is_correct else "incorrect",
            "message": "Excellent! That's correct." if is_correct else "That's not correct, but let's learn from this.",
            "correct_answer": question.answer,
            "user_answer": attempt_data.user_answer,
            "solution_feedback": {
                "solution_approach": clean_solution_text(question.solution_approach) or "Solution approach not available",
                "detailed_solution": clean_solution_text(question.detailed_solution) or "Detailed solution not available",
                "principle_to_remember": clean_solution_text(question.principle_to_remember) or "Principle not available"
            },
            "question_metadata": {
                "subcategory": question.subcategory,
                "difficulty_band": question.difficulty_band,
                "type_of_question": question.type_of_question
            },
            "attempt_id": str(attempt.id),
            "can_proceed": True  # Always allow proceeding after answer submission
        }
        
    except Exception as e:
        logger.error(f"Error submitting session answer: {e}")
        raise HTTPException(status_code=500, detail="Error submitting answer")

# Doubt Conversation Routes - Twelvr New Version

@api_router.post("/doubts/ask", response_model=DoubtResponse)
async def ask_doubt(
    doubt_data: DoubtMessage,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Ask a doubt about a specific question using Gemini AI"""
    try:
        # Get or create conversation record
        conversation_result = await db.execute(
            select(DoubtsConversation).where(
                DoubtsConversation.user_id == current_user.id,
                DoubtsConversation.question_id == doubt_data.question_id
            )
        )
        conversation = conversation_result.scalar_one_or_none()
        
        if not conversation:
            # Create new conversation
            conversation = DoubtsConversation(
                user_id=current_user.id,
                question_id=doubt_data.question_id,
                session_id=doubt_data.session_id,
                conversation_transcript="[]",
                message_count=0,
                gemini_token_usage=0
            )
            db.add(conversation)
            await db.flush()
        
        # Check if conversation is locked (10 message limit reached)
        if conversation.is_locked or conversation.message_count >= 10:
            return DoubtResponse(
                success=False,
                message_count=conversation.message_count,
                remaining_messages=0,
                is_locked=True,
                error="Conversation limit reached. You have used all 10 messages for this question."
            )
        
        # Get question details for context
        question_result = await db.execute(
            select(Question).where(Question.id == doubt_data.question_id)
        )
        question = question_result.scalar_one_or_none()
        
        if not question:
            raise HTTPException(status_code=404, detail="Question not found")
        
        # Parse existing conversation
        import json
        try:
            messages = json.loads(conversation.conversation_transcript) if conversation.conversation_transcript else []
        except json.JSONDecodeError:
            messages = []
        
        # Generate Gemini response
        gemini_response = await generate_doubt_response(
            question=question,
            user_message=doubt_data.message,
            conversation_history=messages
        )
        
        # Add user message and Gemini response to conversation
        messages.append({
            "role": "user",
            "message": doubt_data.message,
            "timestamp": datetime.utcnow().isoformat()
        })
        messages.append({
            "role": "assistant",
            "message": gemini_response["response"],
            "timestamp": datetime.utcnow().isoformat()
        })
        
        # Update conversation record
        conversation.conversation_transcript = json.dumps(messages)
        conversation.message_count = len([m for m in messages if m["role"] == "user"])
        conversation.gemini_token_usage += gemini_response.get("tokens_used", 0)
        conversation.updated_at = datetime.utcnow()
        
        # Lock conversation if 10 messages reached
        if conversation.message_count >= 10:
            conversation.is_locked = True
        
        await db.commit()
        
        remaining_messages = max(0, 10 - conversation.message_count)
        
        return DoubtResponse(
            success=True,
            response=gemini_response["response"],
            message_count=conversation.message_count,
            remaining_messages=remaining_messages,
            is_locked=conversation.is_locked
        )
        
    except Exception as e:
        logger.error(f"Error processing doubt: {e}")
        raise HTTPException(status_code=500, detail="Error processing your doubt")

@api_router.get("/doubts/{question_id}/history", response_model=DoubtConversationHistory)
async def get_doubt_history(
    question_id: str,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get doubt conversation history for a specific question"""
    try:
        conversation_result = await db.execute(
            select(DoubtsConversation).where(
                DoubtsConversation.user_id == current_user.id,
                DoubtsConversation.question_id == question_id
            )
        )
        conversation = conversation_result.scalar_one_or_none()
        
        if not conversation:
            # Return empty conversation
            return DoubtConversationHistory(
                conversation_id="",
                messages=[],
                message_count=0,
                remaining_messages=10,
                is_locked=False
            )
        
        # Parse conversation
        import json
        try:
            messages = json.loads(conversation.conversation_transcript) if conversation.conversation_transcript else []
        except json.JSONDecodeError:
            messages = []
        
        remaining_messages = max(0, 10 - conversation.message_count)
        
        return DoubtConversationHistory(
            conversation_id=str(conversation.id),
            messages=messages,
            message_count=conversation.message_count,
            remaining_messages=remaining_messages,
            is_locked=conversation.is_locked
        )
        
    except Exception as e:
        logger.error(f"Error getting doubt history: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving conversation history")

async def generate_doubt_response(question: Question, user_message: str, conversation_history: List[Dict]) -> Dict[str, Any]:
    """Generate Gemini response for user doubt with Google API (with OpenAI fallback)"""
    try:
        # Create context from question pedagogy fields
        question_context = f"""
QUESTION: {question.stem}
CORRECT ANSWER: {question.answer}

OFFICIAL SOLUTION:
Approach: {question.solution_approach or 'Not provided'}
Detailed Solution: {question.detailed_solution or 'Not provided'}
Principle to Remember: {question.principle_to_remember or 'Not provided'}
"""
        
        # Build conversation context
        conversation_context = ""
        if conversation_history:
            for msg in conversation_history[-6:]:  # Last 6 messages for context
                role = "Student" if msg["role"] == "user" else "Twelvr"
                conversation_context += f"{role}: {msg['message']}\n"
        
        # Gemini system prompt as specified in requirements
        system_prompt = f"""You are a friendly tutor. Keep answers short, clear, and playful. Use plain math (e.g., x^2, sqrt(3)), Markdown lists, and tiny examples. Never rewrite the official Approach/Detailed Solution/Principle. Use them as ground truth; clarify steps, add intuition, or alternative hints. Avoid LaTeX and code unless explicitly requested. Be encouraging; no jargon dumps.

CONTEXT:
{question_context}

CONVERSATION HISTORY:
{conversation_context}

Current student question: {user_message}

Respond as a friendly tutor helping clarify this specific question."""

        # Try Google Gemini API first
        try:
            import google.generativeai as genai
            
            # Configure Gemini
            genai.configure(api_key=os.getenv('GOOGLE_API_KEY'))
            model = genai.GenerativeModel('gemini-1.5-flash')
            
            # Generate response
            response = model.generate_content(system_prompt)
            
            logger.info(f"‚úÖ Gemini doubt response generated successfully")
            return {
                "response": response.text,
                "tokens_used": len(response.text.split()) * 1.3,  # Approximate token count
                "llm_used": "Google Gemini"
            }
            
        except Exception as gemini_error:
            logger.warning(f"Gemini API failed: {gemini_error}, trying OpenAI fallback")
            
            # Fallback to OpenAI
            import openai
            client = openai.OpenAI(api_key=os.getenv('OPENAI_API_KEY'))
            
            response = client.chat.completions.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": system_prompt}
                ],
                max_tokens=500,
                temperature=0.7
            )
            
            logger.info(f"‚úÖ OpenAI fallback response generated successfully")
            return {
                "response": response.choices[0].message.content,
                "tokens_used": response.usage.total_tokens if response.usage else 0,
                "llm_used": "OpenAI (fallback)"
            }
        
    except Exception as e:
        logger.error(f"Error generating doubt response: {e}")
        return {
            "response": "I'm having trouble processing your question right now. Please try again or ask in a different way.",
            "tokens_used": 0,
            "llm_used": "fallback_message"
        }

# Dashboard and Analytics Routes

@api_router.get("/dashboard/mastery")
async def get_mastery_dashboard(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get user's mastery dashboard with category and subcategory progress"""
    try:
        # Get mastery data by topic with parent topic information for category structure
        result = await db.execute(
            select(
                Mastery, 
                Topic.name.label('topic_name'),
                Topic.parent_id,
                func.coalesce(Topic.parent_id.is_(None), True).label('is_parent_topic')
            )
            .join(Topic, Mastery.topic_id == Topic.id)
            .where(Mastery.user_id == current_user.id)
            .order_by(Topic.name)
        )
        
        mastery_records = result.fetchall()
        mastery_data = []
        
        for mastery, topic_name, parent_id, is_parent_topic in mastery_records:
            # Get subcategory data for this topic
            subcategory_result = await db.execute(
                select(
                    Question.subcategory,
                    func.count(Attempt.id).label('attempts_count'),
                    func.avg(
                        case(
                            (Attempt.correct == True, 100),
                            else_=0
                        )
                    ).label('avg_accuracy')
                )
                .join(Attempt, Question.id == Attempt.question_id)
                .where(
                    Question.topic_id == mastery.topic_id,
                    Attempt.user_id == current_user.id
                )
                .group_by(Question.subcategory)
            )
            
            subcategories = []
            for subcat_data in subcategory_result.fetchall():
                if subcat_data.subcategory:  # Only include if subcategory exists
                    subcategories.append({
                        'name': subcat_data.subcategory,
                        'attempts_count': subcat_data.attempts_count or 0,
                        'mastery_percentage': float(subcat_data.avg_accuracy or 0)
                    })
            
            # Determine category with canonical taxonomy format
            category_name = topic_name
            canonical_category = "Unknown"
            
            if parent_id:
                # This is a child topic, get parent name and format as canonical category
                parent_result = await db.execute(
                    select(Topic.name, Topic.category).where(Topic.id == parent_id)
                )
                parent_record = parent_result.first()
                if parent_record:
                    parent_name, parent_category = parent_record
                    category_name = parent_name
                    # Format as canonical taxonomy
                    if parent_category == 'A':
                        canonical_category = "A-Arithmetic"
                    elif parent_category == 'B':
                        canonical_category = "B-Algebra"
                    elif parent_category == 'C':
                        canonical_category = "C-Geometry"
                    elif parent_category == 'D':
                        canonical_category = "D-Number System"
                    elif parent_category == 'E':
                        canonical_category = "E-Modern Math"
                    else:
                        # Fallback based on parent name
                        if 'arithmetic' in parent_name.lower() or 'percentage' in parent_name.lower():
                            canonical_category = "A-Arithmetic"
                        elif 'algebra' in parent_name.lower() or 'equation' in parent_name.lower():
                            canonical_category = "B-Algebra"
                        elif 'geometry' in parent_name.lower() or 'triangle' in parent_name.lower():
                            canonical_category = "C-Geometry"
                        elif 'number' in parent_name.lower() or 'divisib' in parent_name.lower():
                            canonical_category = "D-Number System"
                        elif 'modern' in parent_name.lower() or 'probability' in parent_name.lower():
                            canonical_category = "E-Modern Math"
                        else:
                            canonical_category = f"A-{parent_name}"  # Default to A- prefix
            else:
                # This is a main topic, determine canonical category from topic name
                topic_lower = topic_name.lower()
                if 'arithmetic' in topic_lower or 'percentage' in topic_lower or 'time' in topic_lower:
                    canonical_category = "A-Arithmetic"
                elif 'algebra' in topic_lower or 'equation' in topic_lower or 'progression' in topic_lower:
                    canonical_category = "B-Algebra"
                elif 'geometry' in topic_lower or 'triangle' in topic_lower or 'circle' in topic_lower:
                    canonical_category = "C-Geometry"
                elif 'number' in topic_lower or 'divisib' in topic_lower or 'hcf' in topic_lower:
                    canonical_category = "D-Number System"
                elif 'modern' in topic_lower or 'probability' in topic_lower or 'permutation' in topic_lower:
                    canonical_category = "E-Modern Math"
                else:
                    canonical_category = f"A-{topic_name}"  # Default with topic name
            
            mastery_data.append({
                'topic_name': topic_name,
                'category_name': canonical_category,  # Now formatted as A-Arithmetic, B-Algebra, etc.
                'mastery_percentage': float(mastery.mastery_pct * 100),  # Convert to percentage
                'accuracy_score': float(mastery.accuracy_easy * 100),  # Convert to percentage
                'speed_score': float(mastery.accuracy_med * 100),    # Convert to percentage  
                'stability_score': float(mastery.accuracy_hard * 100), # Convert to percentage
                'questions_attempted': int(mastery.exposure_score),
                'last_attempt_date': mastery.last_updated.isoformat() if mastery.last_updated else None,
                'subcategories': subcategories,
                'is_main_category': parent_id is None  # Flag to identify main categories
            })
        
        # Get detailed progress data
        detailed_progress = await get_detailed_progress_data(db, str(current_user.id))
        
        return {
            'mastery_by_topic': mastery_data,
            'total_topics': len(mastery_data),
            'detailed_progress': detailed_progress
        }
        
    except Exception as e:
        logger.error(f"Error fetching mastery dashboard: {e}")
        return {'mastery_by_topic': [], 'total_topics': 0}

async def get_detailed_progress_data(db: AsyncSession, user_id: str) -> List[Dict]:
    """Get comprehensive progress breakdown showing all canonical taxonomy categories/subcategories with question counts by difficulty"""
    try:
        # Define canonical taxonomy structure for comprehensive coverage
        canonical_categories = {
            "A-Arithmetic": [
                "Time‚ÄìSpeed‚ÄìDistance (TSD)", "Time & Work", "Ratio‚ÄìProportion‚ÄìVariation",
                "Percentages", "Averages & Alligation", "Profit‚ÄìLoss‚ÄìDiscount (PLD)",
                "Simple & Compound Interest (SI‚ÄìCI)", "Mixtures & Solutions"
            ],
            "B-Algebra": [
                "Linear Equations", "Quadratic Equations", "Inequalities", "Progressions",
                "Functions & Graphs", "Logarithms & Exponents", "Special Algebraic Identities"
            ],
            "C-Geometry & Mensuration": [
                "Triangles", "Circles", "Polygons", "Coordinate Geometry",
                "Mensuration (2D & 3D)", "Trigonometry in Geometry"
            ],
            "D-Number System": [
                "Divisibility", "HCF‚ÄìLCM", "Remainders & Modular Arithmetic",
                "Base Systems", "Digit Properties"
            ],
            "E-Modern Math": [
                "Permutation‚ÄìCombination (P&C)", "Probability", "Set Theory & Venn Diagrams"
            ]
        }
        
        # Simplified query using SQLAlchemy ORM instead of raw SQL to avoid AsyncSession parameter issues
        try:
            # Get all active questions with their topics and attempts for this user
            questions_query = select(
                Question.subcategory,
                Question.difficulty_band,
                Topic.category,
                func.count(Question.id).label('total_questions'),
                func.count(case((Attempt.correct == True, Attempt.question_id))).label('solved_correctly'),
                func.count(case((Attempt.user_id == user_id, Attempt.question_id))).label('attempted_questions'),
                func.coalesce(func.avg(case((Attempt.correct == True, 1.0), else_=0.0)), 0).label('accuracy_rate')
            ).select_from(
                Question.__table__.join(Topic.__table__, Question.topic_id == Topic.id)
                .outerjoin(Attempt.__table__, Question.id == Attempt.question_id)
            ).where(
                Question.is_active == True
            ).group_by(
                Question.subcategory,
                Question.difficulty_band,
                Topic.category
            ).order_by(
                Topic.category,
                Question.subcategory,
                Question.difficulty_band
            )
            
            result = await db.execute(questions_query)
            db_rows = result.fetchall()
            
        except Exception as query_error:
            logger.error(f"Error executing questions query: {query_error}")
            # Fallback to empty results if query fails
            db_rows = []
        
        # Create a comprehensive progress structure including all canonical subcategories
        comprehensive_progress = []
        
        for category, subcategories in canonical_categories.items():
            for subcategory in subcategories:
                # Initialize difficulty breakdown
                difficulty_breakdown = {
                    "Easy": {"total": 0, "solved": 0, "attempted": 0, "accuracy": 0.0},
                    "Medium": {"total": 0, "solved": 0, "attempted": 0, "accuracy": 0.0},
                    "Hard": {"total": 0, "solved": 0, "attempted": 0, "accuracy": 0.0}
                }
                
                # Fill with actual data from database
                for row in db_rows:
                    if row.category == category and row.subcategory == subcategory:
                        difficulty = row.difficulty_band or "Medium"
                        if difficulty in difficulty_breakdown:
                            difficulty_breakdown[difficulty] = {
                                "total": int(row.total_questions or 0),
                                "solved": int(row.solved_correctly or 0),
                                "attempted": int(row.attempted_questions or 0),
                                "accuracy": float(row.accuracy_rate or 0) * 100  # Convert to percentage
                            }
                
                # Calculate overall stats for this subcategory
                total_questions = sum(d["total"] for d in difficulty_breakdown.values())
                total_solved = sum(d["solved"] for d in difficulty_breakdown.values())
                total_attempted = sum(d["attempted"] for d in difficulty_breakdown.values())
                overall_accuracy = (total_solved / total_attempted * 100) if total_attempted > 0 else 0.0
                
                # Determine mastery level
                mastery_percentage = (total_solved / total_questions * 100) if total_questions > 0 else 0.0
                if mastery_percentage >= 85:
                    mastery_level = "Mastered"
                elif mastery_percentage >= 60:
                    mastery_level = "On Track"
                else:
                    mastery_level = "Needs Focus"
                
                comprehensive_progress.append({
                    "category": category,
                    "subcategory": subcategory,
                    "difficulty_breakdown": difficulty_breakdown,
                    "summary": {
                        "total_questions": total_questions,
                        "total_solved": total_solved,
                        "total_attempted": total_attempted,
                        "overall_accuracy": round(overall_accuracy, 1),
                        "mastery_percentage": round(mastery_percentage, 1),
                        "mastery_level": mastery_level
                    }
                })
        
        return comprehensive_progress
        
    except Exception as e:
        logger.error(f"Error getting comprehensive progress data: {e}")
        return []


@api_router.get("/dashboard/progress")
async def get_progress_dashboard(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get progress dashboard data"""
    try:
        # Get recent completed sessions (only sessions with ended_at)
        sessions_result = await db.execute(
            select(Session)
            .where(Session.user_id == current_user.id)
            .where(Session.ended_at.is_not(None))
            .order_by(desc(Session.started_at))
            .limit(30)
        )
        sessions = sessions_result.scalars().all()
        
        # Calculate stats
        total_sessions = len(sessions)
        total_minutes = sum([s.duration_sec // 60 for s in sessions if s.duration_sec])
        
        # Get streak (consecutive days with sessions)
        streak = await calculate_study_streak(db, str(current_user.id))
        
        return {
            "total_sessions": total_sessions,
            "total_minutes": total_minutes,
            "current_streak": streak,
            "sessions_this_week": len([s for s in sessions if s.started_at > datetime.utcnow() - timedelta(days=7)])
        }
        
    except Exception as e:
        logger.error(f"Error getting progress dashboard: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.get("/admin/privileges")
async def get_privileged_emails(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get all privileged email addresses (Admin only)"""
    try:
        # Get all privileged emails
        result = await db.execute(
            select(PrivilegedEmail).order_by(PrivilegedEmail.created_at.desc())
        )
        privileged_emails = result.scalars().all()
        
        # Convert to dict format
        emails_data = []
        for email_record in privileged_emails:
            # Get admin name who added this email
            admin_result = await db.execute(
                select(User.full_name).where(User.id == email_record.added_by_admin)
            )
            admin_name = admin_result.scalar() or "Unknown Admin"
            
            emails_data.append({
                "id": email_record.id,
                "email": email_record.email,
                "added_by_admin": admin_name,
                "created_at": email_record.created_at.isoformat(),
                "notes": email_record.notes
            })
        
        return {"privileged_emails": emails_data}
        
    except Exception as e:
        logger.error(f"Error fetching privileged emails: {e}")
        raise HTTPException(status_code=500, detail="Error fetching privileged emails")


@api_router.post("/admin/privileges")
async def add_privileged_email(
    email_data: dict,
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Add an email to privileged list (Admin only)"""
    try:
        email = email_data.get("email", "").strip().lower()
        notes = email_data.get("notes", "").strip()
        
        if not email:
            raise HTTPException(status_code=400, detail="Email address is required")
        
        # Validate email format
        import re
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_pattern, email):
            raise HTTPException(status_code=400, detail="Invalid email format")
        
        # Check if email already exists in privileges
        existing_result = await db.execute(
            select(PrivilegedEmail).where(PrivilegedEmail.email == email)
        )
        if existing_result.scalar():
            raise HTTPException(status_code=400, detail="Email already exists in privileged list")
        
        # Add new privileged email
        new_privileged_email = PrivilegedEmail(
            email=email,
            added_by_admin=current_user.id,
            notes=notes if notes else None
        )
        
        db.add(new_privileged_email)
        await db.commit()
        
        logger.info(f"Admin {current_user.email} added privileged email: {email}")
        
        return {
            "message": "Email successfully added to privileged list",
            "email": email,
            "id": new_privileged_email.id
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error adding privileged email: {e}")
        raise HTTPException(status_code=500, detail="Error adding email to privileged list")


@api_router.delete("/admin/privileges/{email_id}")
async def remove_privileged_email(
    email_id: str,
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Remove an email from privileged list (Admin only)"""
    try:
        # Find the privileged email record
        result = await db.execute(
            select(PrivilegedEmail).where(PrivilegedEmail.id == email_id)
        )
        privileged_email = result.scalar()
        
        if not privileged_email:
            raise HTTPException(status_code=404, detail="Privileged email not found")
        
        email_address = privileged_email.email
        
        # Delete the record
        await db.delete(privileged_email)
        await db.commit()
        
        logger.info(f"Admin {current_user.email} removed privileged email: {email_address}")
        
        return {
            "message": "Email successfully removed from privileged list",
            "email": email_address
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error removing privileged email: {e}")
        raise HTTPException(status_code=500, detail="Error removing email from privileged list")


@api_router.get("/user/session-limit-status")
async def get_user_session_limit_status(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Check user's session access based on subscription status"""
    try:
        # Get completed sessions count for the user
        sessions_result = await db.execute(
            select(func.count(Session.id))
            .where(Session.user_id == current_user.id)
            .where(Session.ended_at.is_not(None))
        )
        completed_sessions = sessions_result.scalar() or 0
        
        # Use subscription access service to check session access
        # Convert AsyncSession to regular Session for the service
        with SessionLocal() as sync_db:
            session_access = subscription_access_service.check_session_access(
                user_id=str(current_user.id),
                user_email=current_user.email,
                completed_sessions=completed_sessions,
                db=sync_db
            )
            
            access_level = session_access["access_level"]
            
            return {
                "completed_sessions": completed_sessions,
                "session_limit": access_level["session_limit"],
                "limit_reached": session_access["limit_reached"],
                "can_start_session": session_access["can_start_session"],
                "sessions_remaining": session_access["sessions_remaining"],
                "access_type": access_level["access_type"],
                "plan_type": access_level["plan_type"],
                "subscription_status": access_level["subscription_status"],
                "unlimited_sessions": access_level["unlimited_sessions"],
                "features": access_level["features"],
                "expires_at": access_level.get("expires_at"),
                "auto_renew": access_level.get("auto_renew", False)
            }
        
    except Exception as e:
        logger.error(f"Error checking session limit status: {e}")
        raise HTTPException(status_code=500, detail="Error checking session limit")

@api_router.get("/user/feature-access/{feature_name}")
async def check_feature_access(
    feature_name: str,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Check if user has access to a specific feature"""
    try:
        # Use subscription access service to check feature access
        with SessionLocal() as sync_db:
            feature_access = subscription_access_service.check_feature_access(
                user_id=str(current_user.id),
                user_email=current_user.email,
                feature_name=feature_name,
                db=sync_db
            )
            
            return {
                "success": True,
                "feature": feature_name,
                "has_access": feature_access["has_access"],
                "plan_type": feature_access["plan_type"],
                "access_type": feature_access["access_type"],
                "subscription_status": feature_access["subscription_status"]
            }
        
    except Exception as e:
        logger.error(f"Error checking feature access: {e}")
        raise HTTPException(status_code=500, detail="Error checking feature access")

@api_router.get("/user/subscription-details")
async def get_user_subscription_details(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get detailed subscription information for the user"""
    try:
        with SessionLocal() as sync_db:
            access_level = subscription_access_service.get_user_access_level(
                user_id=str(current_user.id),
                user_email=current_user.email,
                db=sync_db
            )
            
            return {
                "success": True,
                "access_level": access_level
            }
        
    except Exception as e:
        logger.error(f"Error getting subscription details: {e}")
        raise HTTPException(status_code=500, detail="Error getting subscription details")

@api_router.post("/user/pause-subscription")
async def pause_user_subscription(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Pause user's active subscription (Pro Regular only)"""
    try:
        result = razorpay_service.pause_subscription(str(current_user.id))
        
        if result.get("success"):
            return {
                "success": True,
                "message": result.get("message"),
                "remaining_days": result.get("remaining_days"),
                "paused_at": result.get("paused_at")
            }
        else:
            raise HTTPException(status_code=400, detail=result.get("error", "Failed to pause subscription"))
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error pausing subscription: {e}")
        raise HTTPException(status_code=500, detail="Error pausing subscription")

@api_router.get("/user/resume-subscription-details")
async def get_resume_subscription_details(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get details and cost for resuming paused subscription"""
    try:
        result = razorpay_service.get_resume_payment_details(str(current_user.id))
        
        if result.get("success"):
            return {
                "success": True,
                "subscription_id": result.get("subscription_id"),
                "plan_type": result.get("plan_type"),
                "amount": result.get("amount"),
                "balance_days": result.get("balance_days"),
                "total_days_after_resume": result.get("total_days_after_resume"),
                "message": result.get("message")
            }
        else:
            raise HTTPException(status_code=400, detail=result.get("error", "No paused subscription found"))
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting resume details: {e}")
        raise HTTPException(status_code=500, detail="Error getting resume subscription details")

@api_router.post("/user/create-resume-payment")
async def create_resume_payment_order(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Create payment order for resuming paused subscription"""
    try:
        result = razorpay_service.create_resume_payment_order(
            user_id=str(current_user.id),
            user_email=current_user.email,
            user_name=current_user.full_name,
            user_phone=getattr(current_user, 'phone', None)
        )
        
        if result.get("success"):
            return {
                "success": True,
                "data": {
                    "id": result.get("id"),
                    "order_id": result.get("order_id"),
                    "amount": result.get("amount"),
                    "currency": result.get("currency"),
                    "key": result.get("key"),
                    "plan_name": result.get("plan_name"),
                    "description": result.get("description"),
                    "prefill": result.get("prefill"),
                    "theme": result.get("theme"),
                    "resume_payment": result.get("resume_payment"),
                    "balance_days": result.get("balance_days"),
                    "total_days": result.get("total_days")
                }
            }
        else:
            raise HTTPException(status_code=400, detail=result.get("error", "Failed to create resume payment order"))
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating resume payment order: {e}")
        raise HTTPException(status_code=500, detail="Error creating resume payment order")

@api_router.post("/user/complete-resume-payment")
async def complete_resume_payment(
    payment_data: PaymentVerificationRequest,
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Complete resume payment and activate subscription"""
    try:
        result = razorpay_service.complete_resume_payment(
            payment_id=payment_data.razorpay_payment_id,
            order_id=payment_data.razorpay_order_id,
            signature=payment_data.razorpay_signature,
            user_id=str(current_user.id)
        )
        
        if result.get("success"):
            return {
                "success": True,
                "message": result.get("message"),
                "balance_days_added": result.get("balance_days_added"),
                "new_expiry": result.get("new_expiry"),
                "total_days": result.get("total_days"),
                "amount_paid": result.get("amount_paid")
            }
        else:
            raise HTTPException(status_code=400, detail=result.get("error", "Failed to complete resume payment"))
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error completing resume payment: {e}")
        raise HTTPException(status_code=500, detail="Error completing resume payment")

@api_router.get("/user/subscription-management")
async def get_subscription_management(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get detailed subscription management information"""
    try:
        result = razorpay_service.get_subscription_status(str(current_user.id))
        
        if result.get("success"):
            return {
                "success": True,
                "has_subscription": result.get("has_subscription"),
                "subscription": result.get("subscription")
            }
        else:
            raise HTTPException(status_code=500, detail=result.get("error", "Failed to get subscription status"))
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting subscription management info: {e}")
        raise HTTPException(status_code=500, detail="Error getting subscription management info")


@api_router.get("/dashboard/simple-taxonomy")
async def get_simple_taxonomy_dashboard(
    current_user: User = Depends(require_auth),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get simplified dashboard with complete canonical taxonomy and attempt counts by difficulty"""
    try:
        # Define the complete canonical taxonomy as requested
        canonical_taxonomy = {
            "Arithmetic": {
                "Time-Speed-Distance": ["Basics", "Relative Speed", "Circular Track Motion", "Boats and Streams", "Trains", "Races"],
                "Time-Work": ["Work Time Effeciency", "Pipes and Cisterns", "Work Equivalence"],
                "Ratios and Proportions": ["Simple Rations", "Compound Ratios", "Direct and Inverse Variation", "Partnerships"],
                "Percentages": ["Basics", "Percentage Change", "Successive Percentage Change"],
                "Averages and Alligation": ["Basic Averages", "Weighted Averages", "Alligations & Mixtures", "Three Mixture Alligations"],
                "Profit-Loss-Discount": ["Basics", "Successive Profit/Loss/Discounts", "Marked Price and Cost Price Relations", "Discount Chains"],
                "Simple and Compound Interest": ["Basics", "Difference between Simple Interest and Compound Interests", "Fractional Time Period Compound Interest"],
                "Mixtures and Solutions": ["Replacements", "Concentration Change", "Solid-Liquid-Gas Mixtures"],
                "Partnerships": ["Profit share"]
            },
            "Algebra": {
                "Linear Equations": ["Two variable systems", "Three variable systems", "Dependent and Inconsistent Systems"],
                "Quadratic Equations": ["Roots & Nature of Roots", "Sum and Product of Roots", "Maximum and Minimum Values"],
                "Inequalities": ["Linear Inequalities", "Quadratic Inequalities", "Modulus and Absolute Value", "Arithmetic Mean", "Geometric Mean", "Cauchy Schwarz"],
                "Progressions": ["Arithmetic Progression", "Geometric Progression", "Harmonic Progression", "Mixed Progressions"],
                "Functions and Graphs": ["Linear Functions", "Quadratic Functions", "Polynomial Functions", "Modulus Functions", "Step Functions", "Transformations", "Domain Range", "Composition and Inverse Functions"],
                "Logarithms and Exponents": ["Basics", "Change of Base Formula", "Soliving Log Equations", "Surds and Indices"],
                "Special Algebraic Identities": ["Expansion and Factorisation", "Cubes and Squares", "Binomial Theorem"],
                "Maxima and Minima": ["Optimsation with Algebraic Expressions"],
                "Special Polynomials": ["Remainder Theorem", "Factor Theorem"]
            },
            "Geometry and Mensuration": {
                "Triangles": ["Properties (Angles, Sides, Medians, Bisectors)", "Congruence & Similarity", "Pythagoras & Converse", "Inradius, Circumradius, Orthocentre"],
                "Circles": ["Tangents & Chords", "Angles in a Circle", "Cyclic Quadrilaterals"],
                "Polygons": ["Regular Polygons", "Interior / Exterior Angles"],
                "Coordinate Geometry": ["Distance", "Section Formula", "Midpoint", "Equation of a line", "Slope & Intercepts", "Circles in Coordinate Plane", "Parabola", "Ellipse", "Hyperbola"],
                "Mensuration 2D": ["Area Triangle", "Area Rectangle", "Area Trapezium", "Area Circle", "Sector"],
                "Mensuration 3D": ["Volume Cubes", "Volume Cuboid", "Volume Cylinder", "Volume Cone", "Volume Sphere", "Volume Hemisphere", "Surface Areas"],
                "Trigonometry": ["Heights and Distances", "Basic Trigonometric Ratios"]
            },
            "Number System": {
                "Divisibility": ["Basic Divisibility Rules", "Factorisation of Integers"],
                "HCF-LCM": ["Euclidean Algorithm", "Product of HCF and LCM"],
                "Remainders": ["Basic Remainder Theorem", "Chinese Remainder Theorem", "Cyclicity of Remainders (Last Digits)", "Cyclicity of Remainders (Last Two Digits)"],
                "Base Systems": ["Conversion between bases", "Arithmetic in different bases"],
                "Digit Properties": ["Sum of Digits", "Last Digit Patterns", "Palindromes", "Repetitive Digits"],
                "Number Properties": ["Perfect Squares", "Perfect Cubes"],
                "Number Series": ["Sum of Squares", "Sum of Cubes", "Telescopic Series"],
                "Factorials": ["Properties of Factorials"]
            },
            "Modern Math": {
                "Permutation-Combination": ["Basics", "Circular Permutations", "Permutations with Repetitions", "Permutations with Restrictions", "Combinations with Repetitions", "Combinations with Restrictions"],
                "Probability": ["Classical Probability", "Conditional Probability", "Bayes' Theorem"],
                "Set Theory and Venn Diagram": ["Union and Intersection", "Complement and Difference of Sets", "Multi Set Problems"]
            }
        }
        
        # Get user's attempt data grouped by subcategory, type, and difficulty
        attempt_query = await db.execute(
            select(
                Question.subcategory,
                Question.type_of_question,
                Question.difficulty_band,
                func.count(Attempt.id).label('attempt_count')
            )
            .join(Attempt, Question.id == Attempt.question_id)
            .where(Attempt.user_id == current_user.id)
            .group_by(Question.subcategory, Question.type_of_question, Question.difficulty_band)
        )
        
        attempt_data = attempt_query.fetchall()
        
        # Get total completed sessions count (only sessions with ended_at)
        sessions_result = await db.execute(
            select(func.count(Session.id))
            .where(Session.user_id == current_user.id)
            .where(Session.ended_at.is_not(None))
        )
        total_sessions = sessions_result.scalar() or 0
        
        # Build the response data
        taxonomy_data = []
        
        for category, subcategories in canonical_taxonomy.items():
            for subcategory, types in subcategories.items():
                for type_name in types:
                    # Find attempt counts for this specific combination
                    easy_count = 0
                    medium_count = 0
                    hard_count = 0
                    
                    for row in attempt_data:
                        if (row.subcategory == subcategory and 
                            row.type_of_question == type_name):
                            if row.difficulty_band == 'Easy':
                                easy_count = row.attempt_count
                            elif row.difficulty_band == 'Medium':
                                medium_count = row.attempt_count
                            elif row.difficulty_band == 'Hard' or row.difficulty_band == 'Difficult':
                                hard_count = row.attempt_count
                    
                    taxonomy_data.append({
                        "category": category,
                        "subcategory": subcategory,
                        "type": type_name,
                        "easy_attempts": easy_count,
                        "medium_attempts": medium_count,
                        "hard_attempts": hard_count,
                        "total_attempts": easy_count + medium_count + hard_count
                    })
        
        return {
            "total_sessions": total_sessions,
            "taxonomy_data": taxonomy_data
        }
        
    except Exception as e:
        logger.error(f"Error getting simple taxonomy dashboard: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Admin Routes

@api_router.post("/admin/auto-enrich-all")
async def auto_enrich_all_questions(current_user: User = Depends(require_admin)):
    """
    AUTOMATIC ENRICHMENT API - Follows your schema directive automatically
    NO MORE MANUAL SCRIPTS - Enriches all questions with consistent, high-quality content
    """
    try:
        logger.info("üöÄ Starting automatic enrichment of all questions...")
        
        # Get all questions that need enrichment
        from database import SessionLocal
        db = SessionLocal()
        try:
            questions = db.query(Question).filter(
                or_(
                    Question.solution_approach == None,
                    Question.detailed_solution == None,
                    Question.solution_approach == "To Be Enriched",
                    Question.detailed_solution == "To Be Enriched",
                    Question.solution_approach == "",
                    Question.detailed_solution == "",
                )
            ).all()
            
            if not questions:
                return {
                    "success": True,
                    "message": "All questions are already enriched",
                    "total_questions": 0,
                    "enrichment_needed": 0
                }
            
            logger.info(f"üìä Found {len(questions)} questions needing enrichment")
            
            # Use automatic enrichment service
            auto_service = get_auto_enrichment_service()
            results = await auto_service.batch_enrich_questions(questions, db)
            
            logger.info(f"üéâ Automatic enrichment completed!")
            logger.info(f"üìà Success rate: {results['success_rate']:.1f}%")
            logger.info(f"üìä Average quality: {results['average_quality']:.1f}")
            
            return {
                "success": True,
                "message": "Automatic enrichment completed successfully",
                "results": results,
                "schema_compliance": "All enrichment follows your 3-section schema directive",
                "quality_control": "Anthropic validation included for maximum quality"
            }
        finally:
            db.close()
            
    except Exception as e:
        logger.error(f"‚ùå Auto-enrichment failed: {e}")
        return {
            "success": False,
            "error": str(e),
            "message": "Automatic enrichment encountered an error"
        }

@api_router.post("/admin/enrich-question/{question_id}")
async def auto_enrich_single_question(question_id: str, current_user: User = Depends(require_admin)):
    """
    AUTOMATIC SINGLE QUESTION ENRICHMENT - Schema compliant, high quality
    """
    try:
        from database import SessionLocal
        db = SessionLocal()
        try:
            question = db.query(Question).filter(Question.id == question_id).first()
            
            if not question:
                return {"success": False, "error": "Question not found"}
            
            # Use automatic enrichment service
            auto_service = get_auto_enrichment_service()
            result = await auto_service.enrich_question_automatically(question, db)
            
            if result["success"]:
                return {
                    "success": True,
                    "message": "Question enriched successfully",
                    "quality_score": result.get("quality_score"),
                    "llm_used": result.get("llm_used"),
                    "schema_compliant": True
                }
            else:
                return {
                    "success": False,
                    "error": result.get("error"),
                    "message": "Question enrichment failed"
                }
        finally:
            db.close()
                
    except Exception as e:
        logger.error(f"‚ùå Single question auto-enrichment failed: {e}")
        return {
            "success": False,
            "error": str(e)
        }

@api_router.get("/admin/export-questions-csv")
async def export_questions_csv(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Export all questions as CSV with all columns"""
    try:
        import csv
        import io
        from datetime import datetime
        
        # Get all questions with topic information
        result = await db.execute(
            select(Question, Topic.name.label('topic_name'))
            .join(Topic, Question.topic_id == Topic.id)
            .order_by(Question.created_at.desc())
        )
        
        questions_data = result.fetchall()
        
        # Create CSV in memory
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header with all actual columns from the database
        header = [
            'id',
            'stem',
            'answer',
            'solution_approach',
            'detailed_solution', 
            'category',
            'subcategory',
            'difficulty_score',
            'difficulty_band',
            'frequency_band',
            'frequency_notes',
            'learning_impact',
            'learning_impact_band',
            'importance_index',
            'importance_band',
            'video_url',
            'tags',
            'source',
            'version',
            'is_active',
            'created_at'
        ]
        writer.writerow(header)
        
        # Write question data
        for question, topic_name in questions_data:
            row = [
                str(question.id),
                question.stem or '',
                question.answer or '',
                question.solution_approach or '',
                question.detailed_solution or '',
                topic_name or '',
                question.subcategory or '',
                float(question.difficulty_score) if question.difficulty_score else '',
                question.difficulty_band or '',
                question.frequency_band or '',
                question.frequency_notes or '',
                float(question.learning_impact) if question.learning_impact else '',
                question.learning_impact_band or '',
                float(question.importance_index) if question.importance_index else '',
                question.importance_band or '',
                question.video_url or '',
                ','.join(question.tags) if question.tags else '',
                question.source or '',
                question.version or 1,
                str(question.is_active),
                question.created_at.isoformat() if question.created_at else ''
            ]
            writer.writerow(row)
        
        # Prepare response
        output.seek(0)
        
        return StreamingResponse(
            io.BytesIO(output.getvalue().encode('utf-8')),
            media_type="text/csv",
            headers={
                "Content-Disposition": f"attachment; filename=cat_questions_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            }
        )
        
    except Exception as e:
        logger.error(f"Questions export error: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to export questions: {str(e)}")

@api_router.get("/admin/pyq/uploaded-files")
async def get_uploaded_pyq_files(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get list of all uploaded PYQ CSV files"""
    try:
        from database import PYQFiles
        import json
        
        result = await db.execute(
            select(PYQFiles).order_by(desc(PYQFiles.upload_date))
        )
        files = result.scalars().all()
        
        file_list = []
        for file in files:
            try:
                metadata = json.loads(file.file_metadata) if file.file_metadata else {}
            except:
                metadata = {}
                
            file_list.append({
                "id": file.id,
                "filename": file.filename,
                "upload_date": file.upload_date.isoformat() if file.upload_date else None,
                "year": file.year,
                "file_size": file.file_size,
                "processing_status": file.processing_status,
                "questions_created": metadata.get("questions_created", 0),
                "years_processed": metadata.get("years_processed", []),
                "uploaded_by": metadata.get("uploaded_by", "Unknown"),
                "csv_rows_processed": metadata.get("csv_rows_processed", 0)
            })
        
        return {
            "files": file_list,
            "total_files": len(file_list)
        }
        
    except Exception as e:
        logger.error(f"Error retrieving uploaded files: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve file list")

@api_router.get("/admin/pyq/download-file/{file_id}")
async def download_pyq_file(
    file_id: str,
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Download uploaded PYQ file by recreating CSV from database"""
    try:
        from database import PYQFiles, PYQQuestion, PYQPaper
        import csv
        import io
        from fastapi.responses import StreamingResponse
        
        # Get file record
        file_result = await db.execute(
            select(PYQFiles).where(PYQFiles.id == file_id)
        )
        file_record = file_result.scalar_one_or_none()
        
        if not file_record:
            raise HTTPException(status_code=404, detail="File not found")
        
        # Get file metadata to determine years
        metadata = json.loads(file_record.file_metadata) if file_record.file_metadata else {}
        years_processed = metadata.get("years_processed", [])
        
        # Query PYQ questions from these years (approximate recreation)
        if years_processed:
            questions_result = await db.execute(
                select(PYQQuestion, PYQPaper)
                .join(PYQPaper, PYQQuestion.paper_id == PYQPaper.id)
                .where(PYQPaper.year.in_(years_processed))
                .order_by(PYQPaper.year, PYQQuestion.created_at)
            )
            questions = questions_result.all()
        else:
            # If no year info, get recent questions
            questions_result = await db.execute(
                select(PYQQuestion, PYQPaper)
                .join(PYQPaper, PYQQuestion.paper_id == PYQPaper.id)
                .order_by(desc(PYQQuestion.created_at))
                .limit(metadata.get("questions_created", 50))
            )
            questions = questions_result.all()
        
        # Create CSV content
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow(['stem', 'year', 'image_url'])
        
        # Write data
        for pyq_question, pyq_paper in questions:
            writer.writerow([
                pyq_question.stem,
                pyq_paper.year,
                pyq_question.image_url or ""
            ])
        
        # Create response
        output.seek(0)
        response = StreamingResponse(
            io.BytesIO(output.getvalue().encode('utf-8')),
            media_type='text/csv',
            headers={"Content-Disposition": f"attachment; filename={file_record.filename}"}
        )
        
        return response
        
    except Exception as e:
        logger.error(f"Error downloading file: {e}")
        raise HTTPException(status_code=500, detail="Failed to download file")

@api_router.post("/admin/re-enrich-all-questions")
async def re_enrich_all_questions(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    CRITICAL: Re-enrich ALL questions with generic/wrong solutions
    This endpoint finds and re-enriches questions with generic solutions
    """
    try:
        logger.info("Starting comprehensive question re-enrichment process")
        
        # Find all questions with generic solutions
        generic_patterns = [
            "Mathematical approach to solve this problem",
            "Example answer based on the question pattern", 
            "Detailed solution for:",
            "To be generated by LLM",
            "Answer generation failed",
            "Solution approach not available",
            "Detailed solution not available"
        ]
        
        questions_to_enrich = []
        
        for pattern in generic_patterns:
            result = await db.execute(
                select(Question).where(
                    Question.solution_approach.like(f'%{pattern}%')
                )
            )
            questions = result.scalars().all()
            questions_to_enrich.extend(questions)
        
        # Also check for generic detailed solutions
        result = await db.execute(
            select(Question).where(
                Question.detailed_solution.like('%Detailed solution for:%')
            )
        )
        questions = result.scalars().all()
        questions_to_enrich.extend(questions)
        
        # Remove duplicates
        unique_questions = list({q.id: q for q in questions_to_enrich}.values())
        
        logger.info(f"Found {len(unique_questions)} questions with generic solutions")
        
        if not unique_questions:
            return {
                "status": "success",
                "message": "No questions found with generic solutions",
                "processed": 0,
                "success": 0,
                "failed": 0
            }
        
        # Process each question
        success_count = 0
        failed_count = 0
        
        for question in unique_questions:
            try:
                # Get the topic/category information from the related topic
                topic_result = await db.execute(
                    select(Topic).where(Topic.id == question.topic_id)
                )
                topic = topic_result.scalar_one_or_none()
                hint_category = topic.name if topic else "Arithmetic"
                
                # Use the global LLM pipeline with retry logic
                enrichment_result = await llm_pipeline.complete_auto_generation(
                    stem=question.stem,
                    hint_category=hint_category,
                    hint_subcategory=question.subcategory
                )
                
                # Update question with proper solutions
                question.answer = enrichment_result.get('answer', question.answer)
                question.solution_approach = enrichment_result.get('solution_approach', question.solution_approach)
                question.detailed_solution = enrichment_result.get('detailed_solution', question.detailed_solution)
                question.difficulty_score = enrichment_result.get('difficulty_score', question.difficulty_score)
                question.difficulty_band = enrichment_result.get('difficulty_band', question.difficulty_band)
                question.learning_impact = enrichment_result.get('learning_impact', question.learning_impact)
                
                await db.commit()
                success_count += 1
                
                logger.info(f"Successfully re-enriched question {question.id}")
                
            except Exception as e:
                logger.error(f"Failed to re-enrich question {question.id}: {e}")
                failed_count += 1
                # Continue with other questions
                continue
        
        logger.info(f"Re-enrichment complete: {success_count} success, {failed_count} failed")
        
        return {
            "status": "success",
            "message": f"Re-enrichment complete",
            "processed": len(unique_questions),
            "success": success_count,
            "failed": failed_count,
            "details": f"Successfully updated {success_count} questions with proper LLM-generated solutions"
        }
        
    except Exception as e:
        logger.error(f"Error in re-enrichment process: {e}")
        raise HTTPException(status_code=500, detail=f"Re-enrichment failed: {str(e)}")

# REMOVED: Check Quality and Fix Solutions functionalities 
# These have been removed as per the new Question Upload & Enrichment Workflow requirements

# Export functions for comprehensive data export
@api_router.get("/admin/export-pyq-csv")
async def export_pyq_csv(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Export all PYQ data as CSV with comprehensive information"""
    try:
        import csv
        import io
        from datetime import datetime
        
        # Get all PYQ data with joined information
        result = await db.execute(
            select(
                PYQQuestion,
                PYQPaper.year,
                PYQPaper.slot, 
                PYQIngestion.upload_filename,
                Topic.name.label('topic_name')
            )
            .join(PYQPaper, PYQQuestion.paper_id == PYQPaper.id)
            .join(PYQIngestion, PYQPaper.ingestion_id == PYQIngestion.id)
            .join(Topic, PYQQuestion.topic_id == Topic.id)
            .order_by(PYQPaper.year.desc(), PYQQuestion.created_at.desc())
        )
        
        pyq_data = result.fetchall()
        
        # Create CSV in memory
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header with comprehensive PYQ information
        header = [
            'question_id',
            'year',
            'slot',
            'topic_name',
            'subcategory',
            'type_of_question',
            'question_stem',
            'answer',
            'tags',
            'confirmed_mapping',
            'upload_filename',
            'created_at',
            'paper_id',
            'ingestion_id'
        ]
        writer.writerow(header)
        
        # Write PYQ data
        for pyq_question, year, slot, upload_filename, topic_name in pyq_data:
            row = [
                str(pyq_question.id),
                year or '',
                slot or '',
                topic_name or '',
                pyq_question.subcategory or '',
                pyq_question.type_of_question or '',
                pyq_question.stem or '',
                pyq_question.answer or '',
                pyq_question.tags or '[]',
                str(pyq_question.confirmed),
                upload_filename or '',
                pyq_question.created_at.isoformat() if pyq_question.created_at else '',
                str(pyq_question.paper_id),
                str(pyq_question.paper.ingestion_id) if pyq_question.paper else ''
            ]
            writer.writerow(row)
        
        # Prepare response
        output.seek(0)
        
        return StreamingResponse(
            io.BytesIO(output.getvalue().encode('utf-8')),
            media_type="text/csv",
            headers={
                "Content-Disposition": f"attachment; filename=pyq_database_export_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            }
        )
        
    except Exception as e:
        logger.error(f"PYQ export error: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to export PYQ database: {str(e)}")

@api_router.post("/admin/upload-questions-csv")
async def upload_questions_csv(
    file: UploadFile = File(...),
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    NEW: Enhanced CSV Upload with Question Upload & Enrichment Workflow
    Supports new CSV columns: stem, image_url, answer, solution_approach, principle_to_remember
    Implements immediate LLM enrichment with quality control validation
    """
    try:
        if not file.filename.endswith('.csv'):
            raise HTTPException(status_code=400, detail="File must be a CSV")
            
        # Read CSV content with BOM handling
        import csv
        import io
        content = await file.read()
        
        # Handle UTF-8 BOM properly
        try:
            csv_data = content.decode('utf-8-sig')  # Automatically removes BOM
        except UnicodeDecodeError:
            # Fallback to regular UTF-8 if utf-8-sig fails
            csv_data = content.decode('utf-8')
            
        csv_reader = csv.DictReader(io.StringIO(csv_data))
        
        # Convert to list for processing
        csv_rows = list(csv_reader)
        
        # Validate CSV format - must have 'stem' column
        if not csv_rows:
            raise HTTPException(status_code=400, detail="CSV file is empty")
        
        first_row = csv_rows[0]
        if 'stem' not in first_row:
            raise HTTPException(status_code=400, detail="CSV must contain 'stem' column with question text")
        
        logger.info(f"üöÄ Processing {len(csv_rows)} rows with NEW Question Upload & Enrichment Workflow")
        
        # Process images from Google Drive URLs if image_url column exists
        processed_rows = csv_rows
        if any('image_url' in row for row in csv_rows):
            from google_drive_utils import GoogleDriveImageFetcher
            processed_rows = GoogleDriveImageFetcher.process_csv_image_urls(csv_rows, UPLOAD_DIR)
        
        questions_created = 0
        questions_activated = 0 
        questions_deactivated = 0
        images_processed = 0
        enrichment_results = []
        
        # Initialize the new Unified Enrichment Service
        from unified_enrichment_service import UnifiedEnrichmentService
        unified_enricher = UnifiedEnrichmentService()
        
        for i, row in enumerate(processed_rows):
            try:
                # Extract data from NEW CSV format with admin-provided fields
                stem = row.get('stem', '').strip()
                admin_answer = row.get('answer', '').strip() if row.get('answer') else None
                solution_approach = row.get('solution_approach', '').strip() if row.get('solution_approach') else None
                principle_to_remember = row.get('principle_to_remember', '').strip() if row.get('principle_to_remember') else None
                
                # Image fields (processed by Google Drive utils if applicable)
                has_image = row.get('has_image', False)
                image_url = row.get('image_url', '').strip() if row.get('image_url') else None
                image_alt_text = row.get('image_alt_text', '').strip() if row.get('image_alt_text') else None
                
                # Auto-set has_image based on successful image download
                if image_url and image_url.startswith('/uploads/images/'):
                    has_image = True
                    images_processed += 1
                else:
                    has_image = False
                
                if not stem:
                    logger.warning(f"Row {i+1}: Skipping - missing question stem")
                    continue
                
                # Find a default topic (will be reclassified by LLM)
                topic_result = await db.execute(
                    select(Topic).where(Topic.name == "General")
                )
                topic = topic_result.scalar_one_or_none()
                
                if not topic:
                    # Create a default topic
                    topic = Topic(
                        name="General",
                        slug="general",
                        category="A",
                        centrality=0.5
                    )
                    db.add(topic)
                    await db.flush()
                
                # Create question with admin-provided fields (PROTECTED)
                question = Question(
                    topic_id=topic.id,
                    stem=stem,
                    answer=admin_answer or "Not provided", # ADMIN FIELD - PROTECTED
                    solution_approach=solution_approach or "Not provided", # ADMIN FIELD - PROTECTED  
                    principle_to_remember=principle_to_remember or "Not provided", # ADMIN FIELD - PROTECTED
                    # LLM will populate these fields during immediate enrichment
                    right_answer=None,  # To be generated by LLM
                    subcategory="To be classified",  # To be generated by LLM
                    type_of_question="To be classified", # To be generated by LLM
                    difficulty_band=None, # To be generated by LLM
                    # Image support fields
                    has_image=has_image,
                    image_url=image_url,
                    image_alt_text=image_alt_text,
                    # Metadata 
                    tags=json.dumps(["csv_upload", "new_workflow"]),
                    source="Admin CSV Upload - New Workflow",
                    # Initially inactive until enrichment and validation
                    is_active=False
                )
                
                db.add(question)
                await db.flush()  # Get the question ID
                questions_created += 1
                
                # IMMEDIATE LLM ENRICHMENT (not background) - Generate 5 fields only
                logger.info(f"üéØ Question {questions_created}: Starting immediate LLM enrichment")
                
                enrichment_result = await unified_enricher.enrich_question_comprehensive(
                    stem=stem,
                    admin_answer=admin_answer,
                    question_type="regular"
                )
                
                logger.info(f"ü§ñ Enrichment result for question {questions_created}: {enrichment_result}")
                
                if enrichment_result["success"]:
                    enrichment_data = enrichment_result["enrichment_data"]
                    
                    logger.info(f"üìä Enrichment data: {enrichment_data}")
                    
                    # Log each field being set
                    category = enrichment_data["category"]
                    right_answer = enrichment_data["right_answer"]
                    subcategory = enrichment_data["subcategory"]
                    type_of_question = enrichment_data["type_of_question"]
                    difficulty_band = enrichment_data["difficulty_band"]  # Fixed field name
                    
                    logger.info(f"üè∑Ô∏è Setting category: '{category}'")
                    logger.info(f"‚úÖ Setting right_answer: '{right_answer}'")
                    logger.info(f"üìÇ Setting subcategory: '{subcategory}'")
                    logger.info(f"üî¢ Setting type_of_question: '{type_of_question}'")
                    logger.info(f"‚öñÔ∏è Setting difficulty_band: '{difficulty_band}'")
                    
                    # Update question with all unified enrichment fields
                    # Basic fields
                    question.category = category  # NEW: Store main category
                    question.right_answer = right_answer
                    question.subcategory = subcategory
                    question.type_of_question = type_of_question
                    question.difficulty_band = enrichment_data["difficulty_band"]  # Fixed field name
                    
                    # Enhanced unified fields
                    question.core_concepts = enrichment_data.get("core_concepts")
                    question.solution_method = enrichment_data.get("solution_method")
                    question.concept_difficulty = enrichment_data.get("concept_difficulty")
                    question.operations_required = enrichment_data.get("operations_required")
                    question.problem_structure = enrichment_data.get("problem_structure")
                    question.concept_keywords = enrichment_data.get("concept_keywords")
                    question.quality_verified = enrichment_data.get("quality_verified", False)
                    question.concept_extraction_status = enrichment_data.get("concept_extraction_status", "completed")
                    
                    # Set difficulty score if available
                    if enrichment_data.get("difficulty_score"):
                        question.difficulty_score = enrichment_data["difficulty_score"]
                    
                    # NEW: Mark as LLM verified with constraints
                    question.llm_difficulty_assessment_method = 'llm_verified'
                    question.llm_assessment_attempts = 1
                    question.last_llm_assessment_date = datetime.utcnow()
                    question.llm_assessment_error = None
                    
                    # Update topic based on LLM classification
                    category = enrichment_data["category"]
                    topic_result = await db.execute(
                        select(Topic).where(Topic.name == category)
                    )
                    classified_topic = topic_result.scalar_one_or_none()
                    
                    if classified_topic:
                        question.topic_id = classified_topic.id
                    
                    # NEW: Calculate Dynamic PYQ Frequency (replaces hardcoded values)
                    logger.info(f"üßÆ Calculating dynamic PYQ frequency for question {questions_created}")
                    try:
                        from dynamic_frequency_calculator import DynamicFrequencyCalculator
                        frequency_calculator = DynamicFrequencyCalculator()
                        
                        frequency_result = await frequency_calculator.calculate_true_pyq_frequency(question, db)
                        
                        # Update question with real frequency data
                        question.pyq_frequency_score = frequency_result['frequency_score']
                        question.pyq_conceptual_matches = frequency_result['conceptual_matches_count']
                        question.frequency_analysis_method = 'dynamic_conceptual_matching'
                        
                        logger.info(f"‚úÖ Dynamic frequency calculated: {frequency_result['frequency_score']:.3f} (was hardcoded)")
                        
                    except Exception as freq_error:
                        logger.warning(f"‚ö†Ô∏è Dynamic frequency calculation failed, using fallback: {freq_error}")
                        # Fallback to neutral score instead of hardcoded categories
                        question.pyq_frequency_score = 0.5
                        question.frequency_analysis_method = 'fallback_neutral'
                    
                    # QUALITY CONTROL: Validate admin.answer vs LLM.right_answer
                    question_activated = True
                    validation_message = "No admin answer to validate"
                    
                    if admin_answer and question.right_answer:
                        validation_result = await unified_enricher._validate_answer_consistency(
                            admin_answer=admin_answer,
                            ai_right_answer=question.right_answer,
                            question_stem=stem
                        )
                        
                        if validation_result["matches"]:
                            # Question can be activated due to LLM verification + validation
                            question.is_active = True
                            questions_activated += 1
                            validation_message = f"‚úÖ Validation passed: {validation_result['explanation']}"
                            logger.info(f"‚úÖ Question {questions_created} activated - LLM verified + answers match")
                        else:
                            # LLM verified but validation failed - keep inactive
                            question.is_active = False
                            questions_deactivated += 1
                            validation_message = f"‚ùå Validation failed: {validation_result['explanation']}"
                            logger.warning(f"‚ùå Question {questions_created} deactivated - answer mismatch")
                            question_activated = False
                    else:
                        # No admin answer provided, activate by default
                        question.is_active = True
                        questions_activated += 1
                    
                    enrichment_results.append({
                        "question_number": questions_created,
                        "enrichment_success": True,
                        "question_activated": question_activated,
                        "validation_message": validation_message,
                        "llm_fields": enrichment_data
                    })
                    
                    logger.info(f"‚úÖ Question {questions_created}: Immediate enrichment completed")
                    
                else:
                    # LLM Enrichment failed - record failure with constraints
                    question.llm_difficulty_assessment_method = 'failed'
                    question.llm_assessment_attempts = 1
                    question.last_llm_assessment_date = datetime.utcnow()
                    question.llm_assessment_error = enrichment_result.get("error", "Unknown error")
                    question.is_active = False  # Cannot activate without LLM assessment
                    
                    enrichment_results.append({
                        "question_number": questions_created,
                        "enrichment_success": False,
                        "question_activated": False,
                        "error": enrichment_result.get("error", "Unknown error"),
                        "llm_constraint": "Question cannot be activated without LLM difficulty assessment"
                    })
                    logger.error(f"‚ùå Question {questions_created}: LLM enrichment failed - marked for retry")
                
                # Commit each question individually to avoid rollback issues
                await db.commit()
                
            except Exception as question_error:
                logger.error(f"‚ùå Error processing question {i+1}: {question_error}")
                await db.rollback()
                continue
        
        # Final response with comprehensive statistics
        logger.info(f"üéâ NEW Workflow CSV upload completed: {questions_created} questions, {questions_activated} activated")
        
        return {
            "message": f"Successfully processed {questions_created} questions with NEW Question Upload & Enrichment Workflow",
            "workflow": "Question Upload & Enrichment Workflow - Immediate Processing",
            "statistics": {
                "questions_created": questions_created,
                "questions_activated": questions_activated,
                "questions_deactivated": questions_deactivated,
                "images_processed": images_processed,
                "csv_rows_processed": len(processed_rows)
            },
            "enrichment_summary": {
                "immediate_enrichment": True,
                "llm_fields_generated": ["right_answer", "category", "subcategory", "type_of_question", "difficulty_level"],
                "quality_control_applied": True,
                "admin_fields_protected": ["stem", "answer", "solution_approach", "principle_to_remember", "image_url"]
            },
            "enrichment_results": enrichment_results[:5] if len(enrichment_results) > 5 else enrichment_results,  # Show first 5 for brevity
            "activation_notes": f"{questions_activated}/{questions_created} questions activated after quality control validation"
        }
        
    except Exception as e:
        logger.error(f"‚ùå NEW Workflow CSV upload error: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to upload CSV: {str(e)}")

# Image Upload Endpoints

@api_router.post("/admin/image/upload")
async def upload_question_image(
    file: UploadFile = File(...),
    alt_text: Optional[str] = Form(None),
    current_user: User = Depends(require_admin),
):
    """Upload an image for a question"""
    try:
        # Validate file type
        file_extension = Path(file.filename).suffix.lower()
        if file_extension not in ALLOWED_IMAGE_EXTENSIONS:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid file type. Allowed types: {', '.join(ALLOWED_IMAGE_EXTENSIONS)}"
            )
        
        # Validate file size
        content = await file.read()
        if len(content) > MAX_IMAGE_SIZE:
            raise HTTPException(
                status_code=400,
                detail=f"File too large. Maximum size: {MAX_IMAGE_SIZE // (1024*1024)}MB"
            )
        
        # Generate unique filename
        file_id = str(uuid.uuid4())
        filename = f"{file_id}{file_extension}"
        file_path = UPLOAD_DIR / filename
        
        # Save file
        with open(file_path, "wb") as f:
            f.write(content)
        
        # Generate URL for accessing the image
        image_url = f"/uploads/images/{filename}"
        
        logger.info(f"Image uploaded successfully: {filename} by {current_user.email}")
        
        return {
            "message": "Image uploaded successfully",
            "image_url": image_url,
            "filename": filename,
            "alt_text": alt_text,
            "file_size": len(content)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error uploading image: {e}")
        raise HTTPException(status_code=500, detail="Failed to upload image")

@api_router.delete("/admin/image/{filename}")
async def delete_question_image(
    filename: str,
    current_user: User = Depends(require_admin),
):
    """Delete an uploaded image"""
    try:
        file_path = UPLOAD_DIR / filename
        if not file_path.exists():
            raise HTTPException(status_code=404, detail="Image not found")
        
        # Remove file
        file_path.unlink()
        
        logger.info(f"Image deleted: {filename} by {current_user.email}")
        
        return {"message": "Image deleted successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting image: {e}")
        raise HTTPException(status_code=500, detail="Failed to delete image")

# PYQ Upload Endpoints

@api_router.post("/admin/pyq/upload")
async def upload_pyq_document(
    file: UploadFile = File(...),
    year: int = Form(None),
    slot: Optional[str] = Form(None),
    source_url: Optional[str] = Form(None),
    background_tasks: BackgroundTasks = None,
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Upload PYQ data - Primary support for CSV format with automatic LLM enrichment"""
    try:
        # PRIMARY: CSV-based PYQ upload with LLM enrichment
        if file.filename.endswith('.csv'):
            return await upload_pyq_csv(file, db, current_user)
        
        # MINIMAL LEGACY SUPPORT: Document processing (deprecated)
        # Note: This is kept for minimal backward compatibility but CSV is strongly recommended
        allowed_extensions = ('.docx', '.doc', '.pdf')
        if not file.filename.endswith(allowed_extensions):
            raise HTTPException(
                status_code=400, 
                detail="Primary format: CSV (.csv) with automatic LLM processing. Legacy support: Word/PDF (.docx, .doc, .pdf) with manual processing."
            )
        
        # Validate year for legacy upload
        if not year:
            raise HTTPException(
                status_code=400, 
                detail="Year is required for legacy document upload. Consider using CSV format for better automation."
            )
        
        # Minimal legacy document processing
        file_content = await file.read()
        file_extension = file.filename.split('.')[-1]
        storage_key = f"pyq_legacy_{year}_{slot or 'unknown'}_{uuid.uuid4()}.{file_extension}"
        
        # Create minimal ingestion record
        ingestion = PYQIngestion(
            upload_filename=file.filename,
            storage_key=storage_key,
            year=year,
            slot=slot,
            source_url=source_url,
            pages_count=None,
            ocr_required=False,
            ocr_status="not_needed",
            parse_status="legacy_queued"
        )
        
        db.add(ingestion)
        await db.commit()
        
        # Queue minimal processing (no extensive LLM enrichment for legacy)
        if background_tasks:
            background_tasks.add_task(
                process_pyq_document,
                str(ingestion.id),
                file_content
            )
        
        return {
            "message": "Legacy document uploaded (limited processing)",
            "ingestion_id": str(ingestion.id),
            "filename": file.filename,
            "year": year,
            "slot": slot,
            "status": "legacy_processing_queued",
            "recommendation": "For better results with automatic LLM enrichment, use CSV format with columns: stem, year, image_url"
        }
        
    except Exception as e:
        logger.error(f"PYQ upload error: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to upload PYQ: {str(e)}")

async def upload_pyq_csv(file: UploadFile, db: AsyncSession, current_user: User):
    """
    NEW: CSV-based PYQ upload with automatic LLM enrichment
    CSV columns: stem, image_url, year
    """
    try:
        # Import json module at the top
        import csv
        import io
        import json
        
        # Read CSV content with BOM handling
        content = await file.read()
        
        # Handle UTF-8 BOM properly
        try:
            csv_data = content.decode('utf-8-sig')  # Automatically removes BOM
        except UnicodeDecodeError:
            # Fallback to regular UTF-8 if utf-8-sig fails
            csv_data = content.decode('utf-8')
            
        csv_reader = csv.DictReader(io.StringIO(csv_data))
        
        # Convert to list for processing
        csv_rows = list(csv_reader)
        
        # Validate CSV format
        if not csv_rows:
            raise HTTPException(status_code=400, detail="CSV file is empty")
        
        first_row = csv_rows[0]
        required_columns = ['stem', 'year']
        missing_columns = [col for col in required_columns if col not in first_row]
        if missing_columns:
            raise HTTPException(
                status_code=400, 
                detail=f"CSV must contain required columns: {', '.join(missing_columns)}. Found columns: {', '.join(first_row.keys())}"
            )
        
        logger.info(f"Processing {len(csv_rows)} PYQ questions from CSV with LLM enrichment")
        
        # Process images from Google Drive URLs (same as questions)
        processed_rows = GoogleDriveImageFetcher.process_csv_image_urls(csv_rows, UPLOAD_DIR)
        
        # Group questions by year for paper organization
        questions_by_year = {}
        for row in processed_rows:
            year = int(row.get('year', 2024))
            if year not in questions_by_year:
                questions_by_year[year] = []
            questions_by_year[year].append(row)
        
        total_questions_created = 0
        total_images_processed = 0
        papers_created = []
        
        # Process each year separately
        for year, questions in questions_by_year.items():
            # Create PYQ ingestion record for this year
            ingestion = PYQIngestion(
                upload_filename=f"{file.filename}_year_{year}",
                storage_key=f"pyq_csv_{year}_{uuid.uuid4()}.csv",
                year=year,
                slot="CSV",
                source_url=None,
                pages_count=len(questions),
                ocr_required=False,
                ocr_status="not_needed",
                parse_status="completed"
            )
            db.add(ingestion)
            await db.flush()
            
            # Create PYQ paper record for this year
            paper = PYQPaper(
                year=year,
                slot="CSV",
                source_url=None,
                ingestion_id=str(ingestion.id)
            )
            db.add(paper)
            await db.flush()
            papers_created.append(str(paper.id))
            
            # Process questions for this year
            for i, row in enumerate(questions):
                stem = row.get('stem', '').strip()
                if not stem:
                    logger.warning(f"Skipping row {i+1} for year {year}: empty stem")
                    continue
                
                # Image fields (processed by Google Drive utils)
                has_image = row.get('has_image', False)
                image_url = row.get('image_url', '').strip() if row.get('image_url') else None
                image_alt_text = row.get('image_alt_text', '').strip() if row.get('image_alt_text') else None
                
                if has_image and image_url and image_url.startswith('/uploads/images/'):
                    total_images_processed += 1
                
                # Find or create default topic (will be reclassified by LLM)
                result = await db.execute(select(Topic).where(Topic.name == "General"))
                topic = result.scalar_one_or_none()
                
                if not topic:
                    topic = Topic(
                        name="General",
                        section="QA",
                        slug="general",
                        category="A"
                    )
                    db.add(topic)
                    await db.flush()
                
                # Create PYQ question with minimal data - LLM will enrich everything
                pyq_question = PYQQuestion(
                    paper_id=str(paper.id),
                    topic_id=str(topic.id),
                    stem=stem,
                    answer="To be generated by LLM",
                    subcategory="To be classified by LLM",
                    type_of_question="To be classified by LLM",
                    tags=json.dumps(["pyq_csv_upload", "llm_pending", f"year_{year}"]),
                    confirmed=False  # Will be confirmed after LLM enrichment
                )
                
                db.add(pyq_question)
                total_questions_created += 1
            
            # Mark ingestion as completed
            ingestion.parse_status = "completed"
            ingestion.completed_at = datetime.utcnow()
        
        await db.commit()
        
        # Queue background LLM enrichment for all PYQ questions
        logger.info("Starting background LLM enrichment for all uploaded PYQ questions...")
        
        # Get all PYQ questions created in this batch for enrichment
        recent_pyq_questions = await db.execute(
            select(PYQQuestion).where(
                PYQQuestion.paper_id.in_(papers_created),
                PYQQuestion.confirmed == False  # Only unprocessed questions
            ).order_by(desc(PYQQuestion.created_at)).limit(total_questions_created)
        )
        
        # Queue ENHANCED background enrichment tasks for PYQ questions
        logger.info("Starting ENHANCED background PYQ enrichment with full LLM pipeline...")
        
        for pyq_question in recent_pyq_questions.scalars():
            # Use the NEW enhanced enrichment pipeline instead of basic classification
            asyncio.create_task(enhanced_pyq_enrichment_background(str(pyq_question.id)))
        
        # Store file metadata for tracking
        from database import PYQFiles
        
        file_record = PYQFiles(
            filename=file.filename,
            year=list(questions_by_year.keys())[0] if len(questions_by_year) == 1 else None,  # Single year or mixed
            upload_date=datetime.utcnow(),
            processing_status="completed",
            file_size=len(content),
            storage_path=f"pyq_uploads/{file.filename}",  # Virtual path for tracking
            file_metadata=json.dumps({
                "questions_created": total_questions_created,
                "images_processed": total_images_processed,
                "years_processed": list(questions_by_year.keys()),
                "papers_created": len(papers_created),
                "csv_rows_processed": len(processed_rows),
                "upload_timestamp": datetime.utcnow().isoformat(),
                "uploaded_by": current_user.email
            })
        )
        
        db.add(file_record)
        await db.commit()
        
        logger.info(f"PYQ CSV upload completed: {total_questions_created} questions created across {len(questions_by_year)} years")
        
        return {
            "message": f"Successfully uploaded {total_questions_created} PYQ questions from CSV",
            "questions_created": total_questions_created,
            "images_processed": total_images_processed,
            "years_processed": list(questions_by_year.keys()),
            "papers_created": len(papers_created),
            "csv_rows_processed": len(processed_rows),
            "enrichment_status": "PYQ questions queued for automatic LLM processing (category classification, solution generation, type identification)",
            "note": "PYQ questions will be automatically enriched with categories, subcategories, question types, and solutions by the LLM system",
            "file_id": file_record.id
        }
        
    except Exception as e:
        logger.error(f"PYQ CSV upload error: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to upload PYQ CSV: {str(e)}")

@api_router.get("/admin/pyq/questions")
async def get_pyq_questions(
    limit: int = 100,
    offset: int = 0,
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    Retrieve PYQ questions with pagination (year filtering removed as per user requirement)
    """
    try:
        # Build query without year filtering
        query = select(PYQQuestion).offset(offset).limit(limit).order_by(desc(PYQQuestion.created_at))
        
        result = await db.execute(query)
        pyq_questions = result.scalars().all()
        
        # Format response
        questions_data = []
        for question in pyq_questions:
            question_data = {
                "id": str(question.id),
                "stem": question.stem,
                "subcategory": question.subcategory,
                "type_of_question": question.type_of_question,
                "difficulty_band": getattr(question, 'difficulty_band', None),
                "difficulty_score": float(getattr(question, 'difficulty_score', 0.0)) if getattr(question, 'difficulty_score', None) else None,
                "is_active": getattr(question, 'is_active', False),
                "quality_verified": getattr(question, 'quality_verified', False),
                "concept_extraction_status": getattr(question, 'concept_extraction_status', 'pending'),
                "core_concepts": json.loads(getattr(question, 'core_concepts', '[]')) if getattr(question, 'core_concepts', None) else [],
                "solution_method": getattr(question, 'solution_method', None),
                "created_at": question.created_at.isoformat() if question.created_at else None,
                "last_updated": getattr(question, 'last_updated', question.created_at).isoformat() if getattr(question, 'last_updated', question.created_at) else None
            }
            questions_data.append(question_data)
        
        # Get total count for pagination
        count_query = select(func.count(PYQQuestion.id))
        count_result = await db.execute(count_query)
        total_count = count_result.scalar()
        
        return {
            "questions": questions_data,
            "total": total_count,
            "limit": limit,
            "offset": offset,
            "message": f"Retrieved {len(questions_data)} PYQ questions (total: {total_count})"
        }
        
    except Exception as e:
        logger.error(f"Error retrieving PYQ questions: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve PYQ questions: {str(e)}")

@api_router.get("/admin/pyq/enrichment-status")
async def get_pyq_enrichment_status(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    Get PYQ enrichment status and statistics
    """
    try:
        # Get enrichment statistics
        stats_query = await db.execute(
            select(
                func.count(PYQQuestion.id).label('total_questions'),
                func.sum(case((PYQQuestion.is_active == True, 1), else_=0)).label('active_questions'),
                func.sum(case((PYQQuestion.quality_verified == True, 1), else_=0)).label('quality_verified'),
                func.sum(case((PYQQuestion.concept_extraction_status == 'completed', 1), else_=0)).label('concept_extracted'),
                func.sum(case((PYQQuestion.concept_extraction_status == 'pending', 1), else_=0)).label('pending_enrichment'),
                func.sum(case((PYQQuestion.concept_extraction_status == 'failed', 1), else_=0)).label('failed_enrichment'),
                func.avg(PYQQuestion.difficulty_score).label('avg_difficulty_score')
            )
        )
        
        stats = stats_query.first()
        
        # Get recent enrichment activity (last 24 hours)
        recent_cutoff = datetime.utcnow() - timedelta(hours=24)
        recent_activity_query = await db.execute(
            select(
                func.count(PYQQuestion.id).label('recent_updates')
            ).where(
                or_(
                    PYQQuestion.last_updated >= recent_cutoff,
                    PYQQuestion.created_at >= recent_cutoff
                )
            )
        )
        recent_activity = recent_activity_query.first()
        
        # Get difficulty distribution
        difficulty_distribution_query = await db.execute(
            select(
                PYQQuestion.difficulty_band,
                func.count(PYQQuestion.id).label('count')
            ).where(
                PYQQuestion.difficulty_band.isnot(None)
            ).group_by(PYQQuestion.difficulty_band)
        )
        difficulty_distribution = {row.difficulty_band: row.count for row in difficulty_distribution_query}
        
        # Calculate enrichment completion rate
        total = stats.total_questions or 0
        completed = stats.concept_extracted or 0
        completion_rate = (completed / total * 100) if total > 0 else 0
        
        return {
            "enrichment_statistics": {
                "total_questions": total,
                "active_questions": stats.active_questions or 0,
                "quality_verified": stats.quality_verified or 0,
                "concept_extracted": completed,
                "pending_enrichment": stats.pending_enrichment or 0,
                "failed_enrichment": stats.failed_enrichment or 0,
                "completion_rate": round(completion_rate, 2),
                "avg_difficulty_score": round(float(stats.avg_difficulty_score), 3) if stats.avg_difficulty_score else None
            },
            "recent_activity": {
                "last_24_hours": recent_activity.recent_updates or 0
            },
            "difficulty_distribution": difficulty_distribution,
            "status": "active" if completion_rate > 90 else "in_progress" if completion_rate > 50 else "needs_attention",
            "message": f"PYQ enrichment is {completion_rate:.1f}% complete with {stats.pending_enrichment or 0} questions pending"
        }
        
    except Exception as e:
        logger.error(f"Error getting PYQ enrichment status: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get enrichment status: {str(e)}")

@api_router.post("/admin/pyq/trigger-enrichment")
async def trigger_pyq_enrichment(
    request: TriggerEnrichmentRequest = TriggerEnrichmentRequest(),
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    Manually trigger PYQ enrichment for specific questions or all pending questions
    """
    try:
        # If no specific questions provided, get all pending questions
        if not request.question_ids:
            pending_query = await db.execute(
                select(PYQQuestion.id).where(
                    or_(
                        PYQQuestion.concept_extraction_status == 'pending',
                        PYQQuestion.concept_extraction_status == 'failed',
                        PYQQuestion.is_active == False
                    )
                ).limit(50)  # Limit to prevent overload
            )
            question_ids = [str(row.id) for row in pending_query]
        else:
            question_ids = request.question_ids
        
        if not question_ids:
            return {
                "message": "No questions found that need enrichment",
                "triggered_count": 0
            }
        
        # Trigger enrichment for each question
        triggered_count = 0
        for question_id in question_ids:
            try:
                asyncio.create_task(enhanced_pyq_enrichment_background(question_id))
                triggered_count += 1
            except Exception as task_error:
                logger.error(f"Failed to trigger enrichment for question {question_id}: {task_error}")
        
        logger.info(f"Manually triggered PYQ enrichment for {triggered_count} questions")
        
        return {
            "message": f"Triggered PYQ enrichment for {triggered_count} questions",
            "triggered_count": triggered_count,
            "question_ids": question_ids[:10],  # Show first 10 for reference
            "total_requested": len(question_ids)
        }
        
    except Exception as e:
        logger.error(f"Error triggering PYQ enrichment: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to trigger enrichment: {str(e)}")

@api_router.get("/admin/frequency-analysis-report")
async def get_frequency_analysis_report(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    Generate comprehensive frequency analysis report
    """
    try:
        # Get frequency analysis statistics
        frequency_stats_query = await db.execute(
            select(
                func.count(Question.id).label('total_questions'),
                func.sum(case((Question.pyq_frequency_score > 0, 1), else_=0)).label('questions_with_frequency'),
                func.avg(Question.pyq_frequency_score).label('avg_frequency_score'),
                func.max(Question.pyq_frequency_score).label('max_frequency_score'),
                func.min(case((Question.pyq_frequency_score > 0, Question.pyq_frequency_score), else_=None)).label('min_frequency_score'),
                func.sum(Question.pyq_conceptual_matches).label('total_conceptual_matches')
            ).where(Question.is_active == True)
        )
        
        frequency_stats = frequency_stats_query.first()
        
        # Get frequency distribution by method
        method_distribution_query = await db.execute(
            select(
                Question.frequency_analysis_method,
                func.count(Question.id).label('count'),
                func.avg(Question.pyq_frequency_score).label('avg_score')
            ).where(
                and_(
                    Question.is_active == True,
                    Question.frequency_analysis_method.isnot(None)
                )
            ).group_by(Question.frequency_analysis_method)
        )
        
        method_distribution = {}
        for row in method_distribution_query:
            method_distribution[row.frequency_analysis_method] = {
                "count": row.count,
                "avg_score": round(float(row.avg_score), 4) if row.avg_score else 0
            }
        
        # Get top categories by frequency
        category_frequency_query = await db.execute(
            select(
                Question.category,
                func.count(Question.id).label('question_count'),
                func.avg(Question.pyq_frequency_score).label('avg_frequency'),
                func.sum(Question.pyq_conceptual_matches).label('total_matches')
            ).where(
                and_(
                    Question.is_active == True,
                    Question.category.isnot(None)
                )
            ).group_by(Question.category).order_by(desc(func.avg(Question.pyq_frequency_score)))
        )
        
        category_analysis = []
        for row in category_frequency_query:
            category_analysis.append({
                "category": row.category,
                "question_count": row.question_count,
                "avg_frequency": round(float(row.avg_frequency), 4) if row.avg_frequency else 0,
                "total_conceptual_matches": row.total_matches or 0,
                "frequency_rating": "High" if (row.avg_frequency or 0) > 0.7 else "Medium" if (row.avg_frequency or 0) > 0.4 else "Low"
            })
        
        # Calculate system health metrics
        total_questions = frequency_stats.total_questions or 0
        analyzed_questions = frequency_stats.questions_with_frequency or 0
        analysis_coverage = (analyzed_questions / total_questions * 100) if total_questions > 0 else 0
        
        # Determine system status
        if analysis_coverage > 90:
            system_status = "excellent"
        elif analysis_coverage > 70:
            system_status = "good"
        elif analysis_coverage > 50:
            system_status = "needs_improvement"
        else:
            system_status = "critical"
        
        return {
            "report_generated": datetime.utcnow().isoformat(),
            "system_overview": {
                "total_active_questions": total_questions,
                "questions_with_frequency_analysis": analyzed_questions,
                "analysis_coverage_percentage": round(analysis_coverage, 2),
                "system_status": system_status,
                "avg_frequency_score": round(float(frequency_stats.avg_frequency_score), 4) if frequency_stats.avg_frequency_score else 0,
                "frequency_score_range": {
                    "min": round(float(frequency_stats.min_frequency_score), 4) if frequency_stats.min_frequency_score else 0,
                    "max": round(float(frequency_stats.max_frequency_score), 4) if frequency_stats.max_frequency_score else 0
                },
                "total_conceptual_matches": frequency_stats.total_conceptual_matches or 0
            },
            "analysis_methods": method_distribution,
            "category_analysis": category_analysis[:10],  # Top 10 categories
            "recommendations": [
                "Run nightly frequency updates to maintain accuracy" if analysis_coverage < 90 else "Frequency analysis coverage is excellent",
                "Consider manual enrichment for low-frequency categories" if len([c for c in category_analysis if c["avg_frequency"] < 0.3]) > 3 else "Category frequency distribution is balanced",
                "Monitor PYQ conceptual matching effectiveness" if (frequency_stats.total_conceptual_matches or 0) < (analyzed_questions * 2) else "Conceptual matching is performing well"
            ]
        }
        
    except Exception as e:
        logger.error(f"Error generating frequency analysis report: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to generate report: {str(e)}")

async def enhanced_pyq_enrichment_background(pyq_question_id: str):
    """
    UNIFIED Background task for PYQ question enrichment using comprehensive LLM pipeline
    Uses the new UnifiedEnrichmentService for complete field generation
    """
    try:
        logger.info(f"üöÄ Starting UNIFIED PYQ enrichment for question {pyq_question_id}")
        
        # Get database session
        db_gen = get_async_compatible_db()
        db = await db_gen.__anext__()
        
        try:
            # Get PYQ question
            result = await db.execute(
                select(PYQQuestion).where(PYQQuestion.id == pyq_question_id)
            )
            pyq_question = result.scalar_one_or_none()
            
            if not pyq_question:
                logger.error(f"‚ùå PYQ question {pyq_question_id} not found")
                return False
            
            # Use Advanced LLM Enrichment Service - 100% QUALITY STANDARDS (NO FALLBACKS)
            advanced_enricher = AdvancedLLMEnrichmentService()
            
            # Perform comprehensive enrichment with strict quality standards
            enrichment_result = await advanced_enricher.enrich_question_deeply(
                stem=pyq_question.stem,
                admin_answer=pyq_question.answer,
                question_type="pyq"
            )
            
            if enrichment_result["success"]:
                enrichment_data = enrichment_result["enrichment_data"]
                
                # Update PYQ question with all unified fields
                pyq_question.difficulty_band = enrichment_data.get("difficulty_band")
                pyq_question.difficulty_score = enrichment_data.get("difficulty_score")
                pyq_question.core_concepts = enrichment_data.get("core_concepts")
                pyq_question.solution_method = enrichment_data.get("solution_method")
                pyq_question.concept_difficulty = enrichment_data.get("concept_difficulty")
                pyq_question.operations_required = enrichment_data.get("operations_required")
                pyq_question.problem_structure = enrichment_data.get("problem_structure")
                pyq_question.concept_keywords = enrichment_data.get("concept_keywords")
                pyq_question.quality_verified = enrichment_data.get("quality_verified", False)
                pyq_question.concept_extraction_status = enrichment_data.get("concept_extraction_status", "completed")
                pyq_question.is_active = True  # Activate after successful enrichment
                pyq_question.last_updated = datetime.utcnow()
                
                await db.commit()
                
                logger.info(f"‚úÖ UNIFIED PYQ enrichment completed successfully for question {pyq_question_id}")
                return True
            else:
                logger.error(f"‚ùå UNIFIED PYQ enrichment failed for question {pyq_question_id}: {enrichment_result.get('error')}")
                return False
                
        finally:
            await db.close()
            
    except Exception as e:
        logger.error(f"‚ùå UNIFIED PYQ enrichment exception for question {pyq_question_id}: {e}")
        return False

async def enrich_pyq_question_background(pyq_question_id: str):
    """
    Background task for PYQ question enrichment using LLM
    Similar to question enrichment but specifically for PYQ data
    """
    db = None
    try:
        logger.info(f"üîÑ Starting PYQ enrichment for question {pyq_question_id}")
        
        # Get database session synchronously
        db = next(get_database())
        
        # Get PYQ question
        pyq_question = db.query(PYQQuestion).filter(PYQQuestion.id == pyq_question_id).first()
        
        if not pyq_question:
            logger.error(f"PYQ Question {pyq_question_id} not found for enrichment")
            return
        
        # Apply LLM enrichment for PYQ classification
        logger.info(f"Enriching PYQ question: {pyq_question.stem[:50]}...")
        
        # Use proper LLM enrichment for canonical taxonomy mapping
        from llm_enrichment import LLMEnrichmentPipeline, SimplifiedEnrichmentService
        import os
        
        try:
            # Initialize LLM enrichment pipeline with API key
            llm_api_key = os.getenv('OPENAI_API_KEY')
            if not llm_api_key:
                raise Exception("OPENAI_API_KEY not found in environment")
                
            enrichment_pipeline = LLMEnrichmentPipeline(llm_api_key=llm_api_key)
            
            # Get LLM-based taxonomy classification using existing categorize_question method
            category, subcategory, question_type = await enrichment_pipeline.categorize_question(
                stem=pyq_question.stem,
                hint_category=None,  # Let LLM determine
                hint_subcategory=None  # Let LLM determine
            )
            
            logger.info(f"LLM classification successful: {category} -> {subcategory} -> {question_type}")
            
            # Find matching topic_id from database based on category
            from sqlalchemy import select
            from database import Topic
            topic_result = await db.execute(
                select(Topic).where(Topic.category.like(f"%{category}%"))
            )
            topic = topic_result.scalar_one_or_none()
            suggested_topic_id = topic.id if topic else None
                
        except Exception as llm_error:
            logger.warning(f"LLM enrichment failed for PYQ question {pyq_question_id}: {llm_error}")
            
            # Enhanced fallback with better keyword matching
            stem_lower = pyq_question.stem.lower()
            
            # More comprehensive keyword mapping to canonical taxonomy
            if any(word in stem_lower for word in ['speed', 'distance', 'time', 'train', 'car', 'velocity', 'travel', 'journey', 'meet', 'overtake']):
                subcategory = "Time‚ÄìSpeed‚ÄìDistance (TSD)"
                question_type = "Speed and Distance Calculation"
            elif any(word in stem_lower for word in ['percentage', 'percent', '%', 'increase', 'decrease', 'rise', 'fall', 'change']):
                subcategory = "Percentages"
                question_type = "Percentage Calculation"
            elif any(word in stem_lower for word in ['profit', 'loss', 'cost', 'selling', 'discount', 'markup', 'cp', 'sp', 'marked']):
                subcategory = "Profit‚ÄìLoss‚ÄìDiscount (PLD)"
                question_type = "Commercial Mathematics"
            elif any(word in stem_lower for word in ['triangle', 'circle', 'square', 'rectangle', 'area', 'perimeter', 'diagonal', 'side', 'angle']):
                subcategory = "Triangles"  # More specific canonical mapping
                question_type = "Geometric Calculation"
            elif any(word in stem_lower for word in ['ratio', 'proportion', 'variation', 'directly', 'inversely', 'partnership']):
                subcategory = "Ratio‚ÄìProportion‚ÄìVariation"
                question_type = "Ratio and Proportion"
            elif any(word in stem_lower for word in ['work', 'days', 'complete', 'together', 'efficiency', 'alone']):
                subcategory = "Time & Work"
                question_type = "Work and Time"
            elif any(word in stem_lower for word in ['interest', 'principal', 'rate', 'compound', 'simple', 'amount', 'ci', 'si']):
                subcategory = "Simple & Compound Interest (SI‚ÄìCI)"
                question_type = "Interest Calculation"
            elif any(word in stem_lower for word in ['average', 'mean', 'mixture', 'alligation', 'mix', 'solution']):
                subcategory = "Averages & Alligation"
                question_type = "Average and Mixture"
            elif any(word in stem_lower for word in ['equation', 'linear', 'solve', 'x', 'y', 'variable']):
                subcategory = "Linear Equations"
                question_type = "Algebraic Problem"
            elif any(word in stem_lower for word in ['quadratic', 'x¬≤', 'roots', 'discriminant']):
                subcategory = "Quadratic Equations"
                question_type = "Quadratic Problem"
            else:
                # Still fallback, but with better logging
                subcategory = "Percentages"  # Default to high-frequency topic instead of "General"
                question_type = "Mathematical Problem"
                logger.warning(f"No specific classification found for PYQ {pyq_question_id}, defaulting to Percentages")
            
            suggested_topic_id = None
        
        # Update PYQ question with enriched data
        pyq_question.subcategory = subcategory
        pyq_question.type_of_question = question_type
        
        # Assign proper topic_id if found
        if suggested_topic_id:
            pyq_question.topic_id = suggested_topic_id
            logger.info(f"   - Assigned topic_id: {suggested_topic_id}")
        
        pyq_question.answer = f"Solution to be calculated for: {pyq_question.stem[:30]}..."
        pyq_question.confirmed = True  # Mark as processed
        
        # Update tags to include enrichment info
        tags = json.loads(pyq_question.tags) if pyq_question.tags else []
        tags.extend(["llm_enriched", "auto_classified", subcategory.lower().replace(' ', '_')])
        pyq_question.tags = json.dumps(list(set(tags)))  # Remove duplicates
        
        # Commit changes
        db.commit()
        
        logger.info(f"‚úÖ PYQ enrichment completed for question {pyq_question_id}")
        logger.info(f"   - Subcategory: {subcategory}")
        logger.info(f"   - Question Type: {question_type}")
        
    except Exception as e:
        logger.error(f"‚ùå PYQ enrichment failed for question {pyq_question_id}: {e}")
        if db:
            db.rollback()
    
    finally:
        # Ensure database session is properly closed
        if db:
            try:
                db.close()
            except:
                pass

# Admin Test Endpoints for Conceptual Frequency Analysis

@api_router.post("/admin/enrich-checker/regular-questions-background", dependencies=[Depends(require_admin)])
async def enrich_checker_regular_background(
    current_user: User = Depends(require_admin),
    request: Dict[str, Any] = None
) -> Dict[str, Any]:
    """
    Start background enrichment job for Regular Questions
    Returns immediately with job ID, sends email when complete
    """
    try:
        # Get admin email
        admin_email = current_user.email
        total_questions = None
        
        if request:
            total_questions = request.get("total_questions")
        
        logger.info(f"üöÄ Starting background regular questions enrichment for {admin_email}")
        
        # Start background job
        job_id = background_jobs.start_regular_questions_enrichment(
            admin_email=admin_email,
            total_questions=total_questions
        )
        
        return {
            "success": True,
            "message": "Regular Questions enrichment job started in background",
            "job_id": job_id,
            "admin_email": admin_email,
            "notification": "You will receive an email when the enrichment is complete",
            "estimated_time": "10-30 minutes depending on question count and LLM processing",
            "processing_details": {
                "batch_size": 10,
                "automatic_retries": True,
                "email_notification": True,
                "intelligent_model_switching": True
            }
        }
    
    except Exception as e:
        logger.error(f"‚ùå Failed to start background regular questions enrichment: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to start background enrichment: {str(e)}")

@api_router.post("/admin/enrich-checker/pyq-questions-background", dependencies=[Depends(require_admin)])
async def enrich_checker_pyq_background(
    current_user: User = Depends(require_admin),
    request: Dict[str, Any] = None
) -> Dict[str, Any]:
    """
    Start background enrichment job for PYQ Questions
    Returns immediately with job ID, sends email when complete
    """
    try:
        # Get admin email
        admin_email = current_user.email
        total_questions = None
        
        if request:
            total_questions = request.get("total_questions")
        
        logger.info(f"üöÄ Starting background PYQ questions enrichment for {admin_email}")
        
        # Start background job
        job_id = background_jobs.start_pyq_questions_enrichment(
            admin_email=admin_email,
            total_questions=total_questions
        )
        
        return {
            "success": True,
            "message": "PYQ Questions enrichment job started in background",
            "job_id": job_id,
            "admin_email": admin_email,
            "notification": "You will receive an email when the enrichment is complete",
            "estimated_time": "5-15 minutes depending on question count and LLM processing",
            "processing_details": {
                "batch_size": 10,
                "automatic_retries": True,
                "email_notification": True,
                "intelligent_model_switching": True
            }
        }
    
    except Exception as e:
        logger.error(f"‚ùå Failed to start background PYQ questions enrichment: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to start background enrichment: {str(e)}")

@api_router.get("/admin/enrich-checker/job-status/{job_id}", dependencies=[Depends(require_admin)])
async def get_enrichment_job_status(job_id: str) -> Dict[str, Any]:
    """
    Get status of a background enrichment job
    """
    try:
        job_status = background_jobs.get_job_status(job_id)
        
        if "error" in job_status:
            raise HTTPException(status_code=404, detail="Job not found")
        
        return {
            "success": True,
            "job_status": job_status
        }
    
    except Exception as e:
        logger.error(f"‚ùå Failed to get job status for {job_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to get job status: {str(e)}")

@api_router.get("/admin/enrich-checker/running-jobs", dependencies=[Depends(require_admin)])
async def list_running_enrichment_jobs() -> Dict[str, Any]:
    """
    List all currently running enrichment jobs
    """
    try:
        running_jobs = background_jobs.list_running_jobs()
        
        return {
            "success": True,
            "running_jobs": running_jobs,
            "job_count": len(running_jobs)
        }
    
    except Exception as e:
        logger.error(f"‚ùå Failed to list running jobs: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to list running jobs: {str(e)}")

@api_router.post("/admin/enrich-checker/regular-questions", dependencies=[Depends(require_admin)])
async def enrich_checker_regular(
    request: Dict[str, Any] = None,
    db = Depends(get_database)
) -> Dict[str, Any]:
    """
    Enrich Checker for Regular Questions
    LLM-based quality assessment and re-enrichment system
    """
    try:
        limit = None
        if request:
            limit = request.get("limit")
        
        logger.info(f"üîç Starting Enrich Checker for Regular Questions (limit: {limit})")
        
        # Initialize Enrich Checker Service
        enrich_checker = EnhancedEnrichmentCheckerService()
        
        # Run quality check and re-enrichment
        result = await enrich_checker.check_and_enrich_regular_questions(db, limit)
        
        if result["success"]:
            check_results = result["check_results"]
            
            logger.info("‚úÖ Regular Questions Enrich Checker completed successfully")
            
            return {
                "success": True,
                "message": "Regular Questions Enrichment Quality Check completed",
                "summary": {
                    "total_questions_checked": check_results["total_questions_checked"],
                    "poor_enrichment_identified": check_results["poor_enrichment_identified"],
                    "re_enrichment_successful": check_results["re_enrichment_successful"],
                    "re_enrichment_failed": check_results["re_enrichment_failed"],
                    "perfect_quality_count": check_results["perfect_quality_count"],
                    "perfect_quality_percentage": check_results["perfect_quality_percentage"],
                    "improvement_rate_percentage": check_results["improvement_rate_percentage"]
                },
                "detailed_results": check_results["detailed_results"][:10],  # Show first 10 detailed results
                "processing_completed_at": check_results["processing_completed_at"]
            }
        else:
            logger.error(f"‚ùå Regular Questions Enrich Checker failed: {result['error']}")
            raise HTTPException(status_code=500, detail=f"Enrich Checker failed: {result['error']}")
    
    except Exception as e:
        logger.error(f"‚ùå Enrich Checker Regular Questions error: {e}")
        raise HTTPException(status_code=500, detail=f"Enrich Checker failed: {str(e)}")

@api_router.post("/admin/enrich-checker/pyq-questions", dependencies=[Depends(require_admin)])
async def enrich_checker_pyq(
    request: Dict[str, Any] = None,
    db = Depends(get_database)
) -> Dict[str, Any]:
    """
    Enrich Checker for PYQ Questions
    LLM-based quality assessment and re-enrichment system
    """
    try:
        limit = None
        if request:
            limit = request.get("limit")
        
        logger.info(f"üîç Starting Enrich Checker for PYQ Questions (limit: {limit})")
        
        # Initialize Enrich Checker Service
        enrich_checker = EnhancedEnrichmentCheckerService()
        
        # Run quality check and re-enrichment
        result = await enrich_checker.check_and_enrich_pyq_questions(db, limit)
        
        if result["success"]:
            check_results = result["check_results"]
            
            logger.info("‚úÖ PYQ Questions Enrich Checker completed successfully")
            
            return {
                "success": True,
                "message": "PYQ Questions Enrichment Quality Check completed",
                "summary": {
                    "total_questions_checked": check_results["total_questions_checked"],
                    "poor_enrichment_identified": check_results["poor_enrichment_identified"],
                    "re_enrichment_successful": check_results["re_enrichment_successful"],
                    "re_enrichment_failed": check_results["re_enrichment_failed"],
                    "perfect_quality_count": check_results["perfect_quality_count"],
                    "perfect_quality_percentage": check_results["perfect_quality_percentage"],
                    "improvement_rate_percentage": check_results["improvement_rate_percentage"]
                },
                "detailed_results": check_results["detailed_results"][:10],  # Show first 10 detailed results
                "processing_completed_at": check_results["processing_completed_at"]
            }
        else:
            logger.error(f"‚ùå PYQ Questions Enrich Checker failed: {result['error']}")
            raise HTTPException(status_code=500, detail=f"PYQ Enrich Checker failed: {result['error']}")
    
    except Exception as e:
        logger.error(f"‚ùå Enrich Checker PYQ Questions error: {e}")
        raise HTTPException(status_code=500, detail=f"PYQ Enrich Checker failed: {str(e)}")

async def test_advanced_enrichment(
    request: Dict[str, Any],
    db = Depends(get_database)
) -> Dict[str, Any]:
    """
    Test the new Advanced LLM Enrichment Service with sophisticated analysis
    """
    try:
        question_stem = request.get("question_stem", "")
        admin_answer = request.get("admin_answer", "")
        
        if not question_stem:
            raise HTTPException(status_code=400, detail="question_stem is required")
        
        logger.info(f"üß† Testing Advanced LLM Enrichment on: {question_stem[:50]}...")
        
        # Initialize the Advanced LLM Enrichment Service (NO FALLBACKS)
        advanced_enricher = AdvancedLLMEnrichmentService()
        
        # Perform deep, sophisticated enrichment
        # ADVANCED LLM ENRICHMENT - 100% QUALITY STANDARDS (NO FALLBACKS)
        enrichment_result = await advanced_enricher.enrich_question_deeply(
            stem=question_stem,
            admin_answer=admin_answer,
            question_type="regular"
        )
        
        if enrichment_result["success"]:
            enrichment_data = enrichment_result["enrichment_data"]
            
            logger.info("‚ú® Advanced enrichment successful!")
            
            return {
                "success": True,
                "message": "Advanced LLM enrichment completed successfully",
                "question_stem": question_stem,
                "admin_answer": admin_answer,
                "enrichment_analysis": {
                    "right_answer": enrichment_data.get("right_answer"),
                    "mathematical_foundation": enrichment_data.get("mathematical_foundation"),
                    "solution_elegance": enrichment_data.get("solution_elegance"),
                    "category": enrichment_data.get("category"),
                    "subcategory": enrichment_data.get("subcategory"),
                    "type_of_question": enrichment_data.get("type_of_question"),
                    "difficulty_band": enrichment_data.get("difficulty_band"),
                    "difficulty_score": enrichment_data.get("difficulty_score"),
                    "complexity_reasoning": enrichment_data.get("complexity_reasoning"),
                    "time_estimate_minutes": enrichment_data.get("time_estimate_minutes"),
                    "core_concepts": enrichment_data.get("core_concepts"),
                    "solution_method": enrichment_data.get("solution_method"),
                    "concept_difficulty": enrichment_data.get("concept_difficulty"),
                    "operations_required": enrichment_data.get("operations_required"),
                    "problem_structure": enrichment_data.get("problem_structure"),
                    "concept_keywords": enrichment_data.get("concept_keywords"),
                    "quality_verified": enrichment_data.get("quality_verified"),
                    "quality_score": enrichment_data.get("quality_score")
                },
                "processing_details": {
                    "service_used": "AdvancedLLMEnrichmentService",
                    "analysis_depth": "ultra_sophisticated",
                    "processing_time": enrichment_result.get("processing_time")
                }
            }
        else:
            logger.error(f"‚ùå Advanced enrichment failed: {enrichment_result.get('error')}")
            return {
                "success": False,
                "message": "Advanced LLM enrichment failed",
                "error": enrichment_result.get("error"),
                "question_stem": question_stem
            }
    
    except Exception as e:
        logger.error(f"‚ùå Test advanced enrichment error: {e}")
        raise HTTPException(status_code=500, detail=f"Advanced enrichment test failed: {str(e)}")

@api_router.post("/admin/test/immediate-enrichment")
async def test_immediate_enrichment(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Test immediate LLM enrichment (not background task)"""
    try:
        # Get an inactive question
        result = await db.execute(
            select(Question).where(Question.is_active == False).limit(1)
        )
        test_question = result.scalar_one_or_none()
        
        if not test_question:
            # Create a test question
            from database import Topic
            topic_result = await db.execute(select(Topic).limit(1))
            topic = topic_result.scalar_one()
            
            test_question = Question(
                topic_id=topic.id,
                subcategory="Speed-Time-Distance",
                type_of_question="Average Speed",
                stem="A car travels 200 km in 4 hours. What is its average speed in km/h?",
                answer="To be generated by LLM",
                solution_approach="",
                detailed_solution="",
                is_active=False,
                source="Test"
            )
            db.add(test_question)
            await db.commit()
            await db.refresh(test_question)
        
        logger.info(f"üß™ Testing immediate enrichment for question: {test_question.id}")
        
        # Test immediate enrichment using simple LLM calls
        from emergentintegrations.llm.chat import LlmChat, UserMessage
        
        # Step 1: Generate answer
        chat = LlmChat(
            api_key=OPENAI_API_KEY,
            session_id=f"test_{test_question.id}",
            system_message="You are a math expert. Given a question, provide only the numerical answer."
        ).with_model("claude", "claude-3-5-sonnet-20241022")
        
        user_message = UserMessage(text=f"Question: {test_question.stem}")
        answer_response = await chat.send_message(user_message)
        answer = answer_response.strip()
        
        # Step 2: Generate solution
        solution_chat = LlmChat(
            api_key=OPENAI_API_KEY,
            session_id=f"solution_{test_question.id}",
            system_message="You are a math tutor. Explain how to solve the given problem step by step."
        ).with_model("claude", "claude-3-5-sonnet-20241022")
        
        solution_message = UserMessage(text=f"Question: {test_question.stem}\nAnswer: {answer}\nProvide a step-by-step solution.")
        solution_response = await solution_chat.send_message(solution_message)
        
        # Update the question
        test_question.answer = answer[:100]  # Limit length
        test_question.solution_approach = "Speed = Distance / Time"
        test_question.detailed_solution = solution_response[:500]  # Limit length
        test_question.subcategory = "Speed-Time-Distance"
        test_question.type_of_question = "Average Speed Calculation"
        test_question.difficulty_score = 0.3  # Easy
        test_question.difficulty_band = "Easy"
        test_question.learning_impact = 60.0
        test_question.importance_index = 70.0
        test_question.frequency_band = "High"
        test_question.tags = ["test_enriched", "immediate_processing"]
        test_question.source = "LLM Test Generated"
        test_question.is_active = True
        
        await db.commit()
        
        return {
            "message": "Immediate enrichment completed successfully",
            "question_id": str(test_question.id),
            "enriched_data": {
                "answer": test_question.answer,
                "solution_approach": test_question.solution_approach,
                "detailed_solution": test_question.detailed_solution,
                "is_active": test_question.is_active
            }
        }
        
    except Exception as e:
        logger.error(f"Error in immediate enrichment test: {e}")
        raise HTTPException(status_code=500, detail=f"Test failed: {str(e)}")

@api_router.post("/admin/test/conceptual-frequency")
async def test_conceptual_frequency_analysis(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Test endpoint to manually trigger conceptual frequency analysis"""
    try:
        from conceptual_frequency_analyzer import ConceptualFrequencyAnalyzer
        
        # Initialize analyzer
        frequency_analyzer = ConceptualFrequencyAnalyzer(llm_pipeline)
        
        # Get a sample question
        result = await db.execute(
            select(Question).where(Question.is_active == True).limit(1)
        )
        test_question = result.scalar_one_or_none()
        
        if not test_question:
            raise HTTPException(status_code=404, detail="No active questions found for testing")
        
        logger.info(f"üß™ Testing conceptual frequency for question: {test_question.stem[:100]}...")
        
        # Run conceptual frequency analysis
        freq_result = await frequency_analyzer.calculate_conceptual_frequency(
            db, test_question, years_window=10
        )
        
        return {
            "message": "Conceptual frequency analysis test completed",
            "question_id": str(test_question.id),
            "question_stem": test_question.stem[:100] + "...",
            "analysis_results": freq_result
        }
        
    except Exception as e:
        logger.error(f"Error in conceptual frequency test: {e}")
        raise HTTPException(status_code=500, detail=f"Test failed: {str(e)}")

@api_router.post("/admin/test/time-weighted-frequency")
async def test_time_weighted_frequency_analysis(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Test time-weighted frequency analysis (20-year data, 10-year relevance)"""
    try:
        from time_weighted_frequency_analyzer import TimeWeightedFrequencyAnalyzer, CAT_ANALYSIS_CONFIG
        
        # Initialize time-weighted analyzer
        time_analyzer = TimeWeightedFrequencyAnalyzer(CAT_ANALYSIS_CONFIG)
        
        # Get sample temporal data for analysis
        current_year = datetime.now().year
        
        # Create sample yearly occurrence data (simulating 20 years of PYQ data)
        sample_yearly_occurrences = {
            2024: 8, 2023: 6, 2022: 7, 2021: 5, 2020: 9,  # Last 5 years (high relevance)
            2019: 4, 2018: 6, 2017: 8, 2016: 3, 2015: 5,  # Next 5 years (medium relevance) 
            2014: 2, 2013: 4, 2012: 3, 2011: 2, 2010: 1,  # Older data (lower relevance)
            2009: 2, 2008: 1, 2007: 1, 2006: 0, 2005: 1   # Very old data (minimal relevance)
        }
        
        sample_total_pyq_per_year = {year: 100 for year in sample_yearly_occurrences.keys()}  # Assume 100 questions per year
        
        # Run time-weighted analysis
        temporal_pattern = time_analyzer.create_temporal_pattern(
            concept_id="Time-Speed-Distance_Basic_Speed_Calculation",
            yearly_occurrences=sample_yearly_occurrences,
            total_pyq_count_per_year=sample_total_pyq_per_year
        )
        
        # Generate insights
        insights = time_analyzer.generate_frequency_insights(temporal_pattern)
        
        # Calculate different frequency metrics
        frequency_metrics = time_analyzer.calculate_time_weighted_frequency(
            sample_yearly_occurrences, sample_total_pyq_per_year
        )
        
        return {
            "message": "Time-weighted frequency analysis test completed",
            "config": {
                "total_data_years": CAT_ANALYSIS_CONFIG.total_data_years,
                "relevance_window_years": CAT_ANALYSIS_CONFIG.relevance_window_years,
                "decay_rate": CAT_ANALYSIS_CONFIG.decay_rate
            },
            "sample_data": {
                "yearly_occurrences": sample_yearly_occurrences,
                "data_span": f"{min(sample_yearly_occurrences.keys())}-{max(sample_yearly_occurrences.keys())}"
            },
            "temporal_pattern": {
                "concept_id": temporal_pattern.concept_id,
                "total_occurrences": temporal_pattern.total_occurrences,
                "relevance_window_occurrences": temporal_pattern.relevance_window_occurrences,
                "weighted_frequency_score": temporal_pattern.weighted_frequency_score,
                "trend_direction": temporal_pattern.trend_direction,
                "trend_strength": temporal_pattern.trend_strength,
                "recency_score": temporal_pattern.recency_score
            },
            "frequency_metrics": frequency_metrics,
            "insights": insights,
            "explanation": {
                "approach": "Uses 20 years of PYQ data but emphasizes last 10 years for relevance scoring",
                "weighting": "Recent years get exponentially higher weights in frequency calculation",
                "trend_analysis": "Detects if topic frequency is increasing, stable, or decreasing over time"
            }
        }
        
    except Exception as e:
        logger.error(f"Error in time-weighted frequency test: {e}")
        raise HTTPException(status_code=500, detail=f"Test failed: {str(e)}")

@api_router.post("/admin/run-enhanced-nightly") 
async def run_enhanced_nightly_processing(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Manually trigger enhanced nightly processing with conceptual frequency analysis"""
    try:
        from enhanced_nightly_engine import EnhancedNightlyEngine
        
        # Initialize enhanced nightly engine
        enhanced_engine = EnhancedNightlyEngine(llm_pipeline)
        
        logger.info("üåô Starting manual enhanced nightly processing...")
        
        # Run the enhanced nightly processing
        result = await enhanced_engine.run_nightly_processing(db)
        
        return {
            "message": "Enhanced nightly processing completed",
            "success": True,
            "processing_results": result
        }
        
    except Exception as e:
        logger.error(f"Error in enhanced nightly processing: {e}")
        raise HTTPException(status_code=500, detail=f"Processing failed: {str(e)}")

@api_router.get("/admin/stats")
async def get_admin_stats(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Get admin dashboard statistics"""
    try:
        # Count various entities
        users_count = await db.scalar(select(func.count(User.id)))
        questions_count = await db.scalar(select(func.count(Question.id)))
        attempts_count = await db.scalar(select(func.count(Attempt.id)))
        active_plans_count = await db.scalar(select(func.count(Plan.id)).where(Plan.status == "active"))
        
        return {
            "total_users": users_count,
            "total_questions": questions_count,
            "total_attempts": attempts_count,
            "active_study_plans": active_plans_count,
            "admin_email": ADMIN_EMAIL
        }
        
    except Exception as e:
        logger.error(f"Error getting admin stats: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/admin/enhance-questions")
async def enhance_questions_with_pyq_frequency(
    request: dict,
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    PHASE 1: Enhance questions with PYQ frequency analysis during upload
    TEMPORARILY DISABLED - enhanced_question_processor replaced with mcq_validation_service
    """
    try:
        return {
            "message": "Enhanced question processing temporarily disabled",
            "status": "disabled",
            "reason": "enhanced_question_processor service replaced"
        }
        
    except Exception as e:
        logger.error(f"Error in enhanced question processing: {e}")
        raise HTTPException(status_code=500, detail=f"Enhanced processing failed: {str(e)}")

@api_router.post("/admin/nightly-mcq-validation")
async def nightly_mcq_validation(
    limit: int = 100,
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    Nightly process to validate and fix MCQ options
    Ensures admin answer appears in exactly one MCQ option
    """
    try:
        logger.info(f"üåô Starting nightly MCQ validation (limit: {limit})")
        
        # Run the MCQ validation batch process
        validation_results = await mcq_validation_service.nightly_mcq_validation_batch(limit=limit)
        
        return {
            "message": "Nightly MCQ validation completed",
            "results": validation_results,
            "summary": {
                "total_processed": validation_results["total_processed"],
                "valid_questions": validation_results["valid_questions"],
                "regenerated_questions": validation_results["regenerated_questions"],
                "failed_questions": validation_results["failed_questions"],
                "success_rate": f"{validation_results.get('success_rate', 0):.1f}%"
            }
        }
        
    except Exception as e:
        logger.error(f"Error in nightly MCQ validation: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/admin/validate-single-mcq/{question_id}")
async def validate_single_question_mcq(
    question_id: str,
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    Validate and fix MCQ options for a single question
    """
    try:
        # Get the question
        result = await db.execute(
            select(Question).where(Question.id == question_id)
        )
        question = result.scalar_one_or_none()
        
        if not question:
            raise HTTPException(status_code=404, detail="Question not found")
        
        # Validate and fix MCQ options
        sync_db = next(get_database())
        validation_result = await mcq_validation_service.validate_and_fix_question(question, sync_db)
        sync_db.close()
        
        return {
            "message": f"MCQ validation completed for question {question_id}",
            "result": validation_result
        }
        
    except Exception as e:
        logger.error(f"Error validating single question MCQ: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@api_router.post("/admin/test/enhanced-session")
async def test_enhanced_session_logic(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """
    PHASE 1: Test the enhanced 12-question session logic with all improvements
    """
    try:
        logger.info("Testing PHASE 1 enhanced session logic")
        
        # Create a test session using enhanced logic
        session_result = await adaptive_session_logic.create_personalized_session(
            current_user.id, db
        )
        
        questions = session_result.get("questions", [])
        metadata = session_result.get("metadata", {})
        
        # Analyze the results
        analysis = {
            "session_created": len(questions) > 0,
            "total_questions": len(questions),
            "enhancement_level": session_result.get("enhancement_level", "unknown"),
            "personalization_applied": session_result.get("personalization_applied", False),
            "metadata_analysis": {
                "learning_stage": metadata.get("learning_stage"),
                "dynamic_adjustment": metadata.get("dynamic_adjustment_applied", False),
                "base_distribution": metadata.get("base_distribution", {}),
                "applied_distribution": metadata.get("applied_distribution", {}),
                "pyq_frequency_stats": metadata.get("pyq_frequency_analysis", {}),
                "subcategory_diversity": metadata.get("subcategory_diversity", 0),
                "cooldown_periods": metadata.get("cooldown_periods_used", {}),
                "weak_areas_targeted": metadata.get("weak_areas_targeted", 0)
            },
            "question_analysis": []
        }
        
        # Analyze individual questions
        for q in questions[:5]:  # First 5 questions for sample
            analysis["question_analysis"].append({
                "id": str(q.id),
                "subcategory": q.subcategory,
                "difficulty": q.difficulty_band,
                "pyq_frequency_score": float(q.pyq_frequency_score or 0.5),
                "frequency_band": q.frequency_band,
                "analysis_method": q.frequency_analysis_method
            })
        
        return {
            "message": "PHASE 1 enhanced session logic test completed",
            "status": "success",
            "enhancement_features": {
                "pyq_frequency_integration": "‚úÖ Active",
                "dynamic_category_quotas": "‚úÖ Active", 
                "subcategory_diversity_caps": "‚úÖ Active",
                "differential_cooldowns": "‚úÖ Active"
            },
            "test_results": analysis
        }
        
    except Exception as e:
        logger.error(f"Error testing enhanced session logic: {e}")
        raise HTTPException(status_code=500, detail=f"Enhanced session test failed: {str(e)}")

@api_router.post("/admin/expire-subscriptions")
async def expire_subscriptions_job(
    current_user: User = Depends(require_admin),
    db: AsyncSession = Depends(get_async_compatible_db)
):
    """Manually trigger subscription expiry job (Admin only)"""
    try:
        with SessionLocal() as sync_db:
            result = subscription_access_service.expire_subscriptions(sync_db)
            
        if result["success"]:
            logger.info(f"Subscription expiry job completed: {result['expired_count']} expired, {result['auto_renewed_count']} renewed")
            return {
                "success": True,
                "message": f"Processed subscriptions: {result['expired_count']} expired, {result['auto_renewed_count']} auto-renewed",
                "details": result
            }
        else:
            raise HTTPException(status_code=500, detail=f"Subscription expiry job failed: {result['error']}")
            
    except Exception as e:
        logger.error(f"Error running subscription expiry job: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Background Tasks

async def enrich_question_background(question_id: str, hint_category: str = None, hint_subcategory: str = None):
    """
    OPTION 2: Enhanced background task with comprehensive processing
    Step 1: Basic LLM enrichment 
    Step 2: PYQ frequency analysis (PHASE 1 enhancement)
    
    Fixed: Proper atomic transaction handling to prevent persistence issues
    """
    db = None
    try:
        logger.info(f"üîÑ Starting ENHANCED background processing for question {question_id}")
        
        # Get database session synchronously with proper session management
        db = next(get_database())
        
        # ATOMIC TRANSACTION: Do both steps in a single transaction to ensure persistence
        try:
            # Get question
            question = db.query(Question).filter(Question.id == question_id).first()
            
            if not question:
                logger.error(f"Question {question_id} not found for enhanced enrichment")
                return
            
            logger.info(f"Step 1: REVISED enrichment for question {question_id} - Protecting admin fields")
            
            # REVISED FLOW: Use updated LLM enrichment pipeline that protects admin fields
            from llm_enrichment import LLMEnrichmentService
            
            try:
                # Use the NEW enrichment service that protects admin fields
                enrichment_service = LLMEnrichmentService()
                enrichment_result = await enrichment_service.enrich_question_automatically(question, db)
                
                if enrichment_result["success"]:
                    logger.info(f"‚úÖ REVISED enrichment successful for question {question_id}")
                    logger.info(f"Admin fields protected: {enrichment_result.get('admin_fields_protected', False)}")
                    logger.info(f"Right answer generated: {enrichment_result.get('right_answer_generated', False)}")
                    logger.info(f"Metadata enriched: {enrichment_result.get('metadata_enriched', False)}")
                else:
                    logger.error(f"‚ùå REVISED enrichment failed: {enrichment_result.get('error')}")
                
            except Exception as llm_error:
                logger.error(f"LLM enrichment failed for question {question_id}: {llm_error}")
                # Minimal fallback - only set basic metadata, don't touch admin fields
                if not question.difficulty_band:
                    question.difficulty_band = "Medium"
                if not question.frequency_band:
                    question.frequency_band = "Medium"
            question.importance_index = 70.0
            question.frequency_band = "High"
            question.tags = json.dumps(["enhanced_processing", "option_2_test"])
            question.source = "OPTION 2 Enhanced Processing"
            
            logger.info(f"Step 2: PYQ frequency analysis for question {question_id}")
            
            # PHASE 1: PYQ frequency scoring based on subcategory analysis
            high_freq_categories = [
                'Time‚ÄìSpeed‚ÄìDistance (TSD)', 'Percentages', 'Profit‚ÄìLoss‚ÄìDiscount (PLD)',
                'Linear Equations', 'Triangles', 'Divisibility', 'Permutation‚ÄìCombination (P&C)'
            ]
            
            medium_freq_categories = [
                'Time & Work', 'Ratio‚ÄìProportion‚ÄìVariation', 'Averages & Alligation',
                'Simple & Compound Interest (SI‚ÄìCI)', 'Quadratic Equations', 'Circles',
                'HCF‚ÄìLCM', 'Probability'
            ]
            
            if question.subcategory in high_freq_categories:
                pyq_score = 0.8
                frequency_method = 'high_frequency_estimate'
            elif question.subcategory in medium_freq_categories:
                pyq_score = 0.6
                frequency_method = 'medium_frequency_estimate'
            else:
                pyq_score = 0.5
                frequency_method = 'default_frequency_estimate'
            
            # Update question with PYQ frequency data
            question.pyq_frequency_score = pyq_score
            question.frequency_analysis_method = frequency_method
            question.frequency_last_updated = datetime.utcnow()
            
            # Activate question after successful processing
            question.is_active = True
            
            # SINGLE ATOMIC COMMIT: Commit all changes at once
            db.commit()
            
            # Verify the transaction worked by re-querying with fresh session
            db.expunge_all()  # Clear session cache
            verification_query = db.query(Question).filter(Question.id == question_id).first()
            
            if verification_query and verification_query.answer and verification_query.answer != "To be generated by LLM":
                logger.info(f"‚úÖ ENHANCED processing completed successfully for question {question_id}")
                logger.info(f"   - Answer: {verification_query.answer}")
                logger.info(f"   - PYQ Score: {verification_query.pyq_frequency_score}")
                logger.info(f"   - Active: {verification_query.is_active}")
            else:
                logger.warning(f"‚ö†Ô∏è Verification failed for question {question_id}")
                logger.warning(f"   - Answer: {getattr(verification_query, 'answer', 'NOT FOUND')}")
                logger.warning(f"   - Active: {getattr(verification_query, 'is_active', 'NOT FOUND')}")
            
        except Exception as transaction_error:
            logger.error(f"‚ùå Transaction failed for question {question_id}: {transaction_error}")
            db.rollback()
            
            # FALLBACK: Try emergency activation with minimal data
            try:
                question = db.query(Question).filter(Question.id == question_id).first()
                if question:
                    question.is_active = True
                    question.pyq_frequency_score = 0.5  # Default score
                    question.frequency_analysis_method = 'emergency_fallback'
                    # Don't try to set answer if it caused the issue
                    db.commit()
                    logger.info(f"üîß Applied emergency fallback for question {question_id}")
            except Exception as fallback_error:
                logger.error(f"üí• Emergency fallback also failed for question {question_id}: {fallback_error}")
        
        logger.info(f"üéâ ENHANCED background processing completed for question {question_id}")
        
    except Exception as e:
        logger.error(f"‚ùå Critical error in enhanced background processing for question {question_id}: {e}")
        
    finally:
        # Ensure database session is properly closed
        if db:
            try:
                db.close()
            except:
                pass

async def process_pyq_document(ingestion_id: str, file_content: bytes):
    """Background task to process PYQ document"""
    try:
        async for db in get_async_compatible_db():
            # Get ingestion record
            result = await db.execute(select(PYQIngestion).where(PYQIngestion.id == ingestion_id))
            ingestion = result.scalar_one_or_none()
            
            if not ingestion:
                logger.error(f"Ingestion {ingestion_id} not found")
                return
            
            # Update status
            ingestion.parse_status = "running"
            await db.commit()
            
            # Process Word document
            doc = Document(io.BytesIO(file_content))
            
            # Extract text
            full_text = []
            for paragraph in doc.paragraphs:
                if paragraph.text.strip():
                    full_text.append(paragraph.text.strip())
            
            document_text = "\n".join(full_text)
            
            # Use LLM to extract questions (simplified version)
            # In production, this would be more sophisticated
            
            # Create PYQ paper record
            pyq_paper = PYQPaper(
                year=ingestion.year,
                slot=ingestion.slot,
                source_url=ingestion.source_url,
                ingestion_id=ingestion.id
            )
            
            db.add(pyq_paper)
            await db.flush()
            
            # Update ingestion status
            ingestion.parse_status = "done"
            ingestion.completed_at = datetime.utcnow()
            ingestion.parse_log = f"Processed document with {len(full_text)} paragraphs"
            
            await db.commit()
            logger.info(f"PYQ document {ingestion_id} processed successfully")
            break  # Exit the async for loop
            
    except Exception as e:
        logger.error(f"Error processing PYQ document: {e}")
        # Update ingestion status to failed
        try:
            async for db in get_async_compatible_db():
                result = await db.execute(select(PYQIngestion).where(PYQIngestion.id == ingestion_id))
                ingestion = result.scalar_one_or_none()
                if ingestion:
                    ingestion.parse_status = "failed"
                    ingestion.parse_log = str(e)
                    await db.commit()
                break  # Exit the async for loop
        except:
            pass

# Utility Functions

async def calculate_study_streak(db: AsyncSession, user_id: str) -> int:
    """Calculate current study streak for a user"""
    try:
        # Get completed sessions ordered by date
        sessions_result = await db.execute(
            select(Session)
            .where(Session.user_id == user_id)
            .where(Session.ended_at.is_not(None))
            .order_by(desc(Session.started_at))
        )
        sessions = sessions_result.scalars().all()
        
        if not sessions:
            return 0
        
        # Calculate consecutive days
        streak = 0
        current_date = datetime.utcnow().date()
        
        session_dates = set()
        for session in sessions:
            session_dates.add(session.started_at.date())
        
        # Count consecutive days backwards from today
        while current_date in session_dates:
            streak += 1
            current_date -= timedelta(days=1)
        
        return streak
        
    except Exception as e:
        logger.error(f"Error calculating streak: {e}")
        return 0

# Include router
app.include_router(api_router)

# Add middleware
app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Startup event
@app.on_event("startup")
async def startup_event():
    logger.info("üöÄ CAT Preparation Platform v2.0 Starting...")
    
    # Initialize database
    init_database()
    logger.info("üìä Database initialized")
    
    # Note: Topic creation can be done manually via admin interface
    logger.info("‚úÖ Startup complete - Database ready")
    
    # Create diagnostic set if needed - DISABLED
    # async for db in get_async_compatible_db():
    #     await diagnostic_system.create_diagnostic_set(db)
    #     break
    # logger.info("üéØ Diagnostic system initialized")
    
    # Start background job processing
    if OPENAI_API_KEY:
        start_background_processing(OPENAI_API_KEY)
        logger.info("‚è∞ Background job processing started")
    else:
        logger.warning("‚ö†Ô∏è Background jobs not started - missing OPENAI_API_KEY")
    
    logger.info(f"üìß Admin Email: {ADMIN_EMAIL}")
    logger.info("‚úÖ CAT Preparation Platform v2.0 Ready!")

@app.on_event("shutdown")
async def shutdown_event():
    logger.info("üõë CAT Preparation Platform v2.0 Shutting down...")
    
    # Stop background job processing
    stop_background_processing()
    logger.info("‚è∞ Background job processing stopped")
    
    logger.info("‚úÖ CAT Preparation Platform v2.0 Shutdown complete!")

async def create_initial_topics():
    """Create initial topic structure from canonical taxonomy"""
    try:
        async for db in get_async_compatible_db():
            # Check if topics already exist
            existing_topics = await db.execute(select(Topic).limit(1))
            if existing_topics.scalar_one_or_none():
                break  # Topics already created
            
            from llm_enrichment import CANONICAL_TAXONOMY
            
            # Create main categories and subcategories
            for category, subcategories in CANONICAL_TAXONOMY.items():
                # Create main category
                main_topic = Topic(
                    name=category,
                    slug=category.lower().replace(" ", "_").replace("&", "and"),
                    centrality=0.8  # Main categories are central
                )
                db.add(main_topic)
                await db.flush()  # Get ID
                
                # Create subcategories
                for subcategory, details in subcategories.items():
                    sub_topic = Topic(
                        name=subcategory,
                        parent_id=main_topic.id,
                        slug=subcategory.lower().replace(" ", "_").replace("‚Äì", "_").replace("(", "").replace(")", ""),
                        centrality=0.6  # Subcategories are moderately central
                    )
                    db.add(sub_topic)
            
            await db.commit()
            logger.info("Created initial topics from canonical taxonomy")
            break
            
    except Exception as e:
        logger.error(f"Error creating initial topics: {e}")