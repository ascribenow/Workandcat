#!/usr/bin/env python3
"""
Debug PYQ Semantic Matching Issue
"""

import asyncio
import os
import json
from pyq_enrichment_service import pyq_enrichment_service

async def debug_pyq_semantic_matching():
    """Debug the semantic matching issue by showing raw LLM output"""
    
    print("üêõ DEBUGGING PYQ SEMANTIC MATCHING ISSUE")
    print("=" * 60)
    
    # Test sample PYQ question
    test_stem = """
    A train travels 120 km in 2 hours. Another train travels 180 km in 3 hours. 
    What is the ratio of their speeds?
    """
    
    print(f"üìö Test Question: {test_stem.strip()}")
    print("\nüîç Step-by-step debugging...")
    
    try:
        # Call the comprehensive analysis directly to see raw LLM output
        print("\nüöÄ Step 1: Testing Stage 1-4 Comprehensive Analysis...")
        comprehensive_result = await pyq_enrichment_service._perform_comprehensive_analysis(
            stem=test_stem.strip(),
            current_answer="To be generated by LLM"
        )
        
        print("\nüìä RAW LLM OUTPUT FROM COMPREHENSIVE ANALYSIS:")
        print("=" * 50)
        for key, value in comprehensive_result.items():
            if isinstance(value, str) and len(value) > 100:
                print(f"{key}: {value[:100]}...")
            else:
                print(f"{key}: {value}")
        
        # Test semantic matching separately
        print("\nüéØ Step 2: Testing Enhanced Semantic Matching...")
        print(f"Input to semantic matching:")
        print(f"  Category: '{comprehensive_result.get('category', 'N/A')}'")
        print(f"  Subcategory: '{comprehensive_result.get('subcategory', 'N/A')}'")
        print(f"  Type: '{comprehensive_result.get('type_of_question', 'N/A')}'")
        
        # Import canonical taxonomy service directly
        from canonical_taxonomy_service import canonical_taxonomy_service
        
        # Test each matching step
        print("\nüîç Step 2a: Testing Subcategory Matching...")
        matched_subcategory = await canonical_taxonomy_service.match_subcategory_without_category(
            comprehensive_result.get('subcategory', '')
        )
        print(f"  Result: '{comprehensive_result.get('subcategory')}' ‚Üí '{matched_subcategory}'")
        
        if matched_subcategory:
            print("\nüîç Step 2b: Testing Question Type Matching...")
            matched_type = await canonical_taxonomy_service.match_question_type_within_subcategory(
                comprehensive_result.get('type_of_question', ''),
                matched_subcategory
            )
            print(f"  Result: '{comprehensive_result.get('type_of_question')}' ‚Üí '{matched_type}'")
            
            if matched_type:
                print("\nüîç Step 2c: Testing Category Lookup...")
                matched_category = canonical_taxonomy_service.lookup_category_by_combination(
                    matched_subcategory, matched_type
                )
                print(f"  Result: lookup('{matched_subcategory}' + '{matched_type}') ‚Üí '{matched_category}'")
            else:
                print("‚ùå Question type matching failed, skipping category lookup")
        else:
            print("‚ùå Subcategory matching failed, skipping subsequent steps")
        
        # Show available taxonomy for comparison
        print("\nüìã CANONICAL TAXONOMY SAMPLE (for comparison):")
        from canonical_taxonomy_data import CANONICAL_TAXONOMY
        
        # Show first few categories, subcategories, and types
        count = 0
        for category, subcategories in CANONICAL_TAXONOMY.items():
            print(f"\nCategory: {category}")
            sub_count = 0
            for subcategory, data in subcategories.items():
                if sub_count < 2:  # Show only first 2 subcategories per category
                    print(f"  Subcategory: {subcategory}")
                    type_count = 0
                    for question_type in data['types'].keys():
                        if type_count < 2:  # Show only first 2 types per subcategory
                            print(f"    Type: {question_type}")
                            type_count += 1
                    sub_count += 1
            count += 1
            if count >= 2:  # Show only first 2 categories
                break
        
        # Test complete flow
        print("\nüîó Step 3: Testing Complete Semantic Matching Flow...")
        verification_result = await pyq_enrichment_service._perform_semantic_matching_and_verification(
            test_stem.strip(), comprehensive_result
        )
        
        print("üìä SEMANTIC MATCHING RESULTS:")
        print("=" * 40)
        for key, value in verification_result.items():
            print(f"{key}: {value}")
            
    except Exception as e:
        print(f"‚ùå Debug error: {e}")
        import traceback
        traceback.print_exc()
    
    print("\nüéâ Semantic Matching Debug Complete!")

if __name__ == "__main__":
    if not os.getenv('OPENAI_API_KEY'):
        print("‚ö†Ô∏è OPENAI_API_KEY not set - tests may fail")
    
    asyncio.run(debug_pyq_semantic_matching())