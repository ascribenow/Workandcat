import requests
import sys
import json
from datetime import datetime
import time
import os

class CATBackendTester:
    def __init__(self, base_url="https://7c02cfe7-3550-46e8-a144-11935599c1f5.preview.emergentagent.com/api"):
        self.base_url = base_url
        self.student_user = None
        self.admin_user = None
        self.student_token = None
        self.admin_token = None
        self.tests_run = 0
        self.tests_passed = 0
        self.sample_question_id = None
        self.diagnostic_id = None
        self.session_id = None
        self.plan_id = None

    def run_test(self, name, method, endpoint, expected_status, data=None, headers=None):
        """Run a single API test"""
        url = f"{self.base_url}/{endpoint}" if not endpoint.startswith('http') else endpoint
        if headers is None:
            headers = {'Content-Type': 'application/json'}

        self.tests_run += 1
        print(f"\nüîç Testing {name}...")
        print(f"   URL: {url}")
        
        try:
            if method == 'GET':
                response = requests.get(url, headers=headers)
            elif method == 'POST':
                response = requests.post(url, json=data, headers=headers)
            elif method == 'PUT':
                response = requests.put(url, json=data, headers=headers)
            elif method == 'DELETE':
                response = requests.delete(url, headers=headers)

            success = response.status_code == expected_status
            if success:
                self.tests_passed += 1
                print(f"‚úÖ Passed - Status: {response.status_code}")
                try:
                    response_data = response.json()
                    print(f"   Response: {json.dumps(response_data, indent=2)[:200]}...")
                    return True, response_data
                except:
                    return True, {}
            else:
                print(f"‚ùå Failed - Expected {expected_status}, got {response.status_code}")
                try:
                    error_data = response.json()
                    print(f"   Error: {error_data}")
                except:
                    print(f"   Error: {response.text}")
                return False, {}

        except Exception as e:
            print(f"‚ùå Failed - Error: {str(e)}")
            return False, {}

    def test_critical_llm_solution_re_enrichment(self):
        """CRITICAL: Test and fix all questions with generic/wrong solutions in database"""
        print("üö® CRITICAL LLM SOLUTION RE-ENRICHMENT TESTING")
        print("=" * 60)
        print("URGENT REQUIREMENT: Re-enrich ALL questions with generic/wrong solutions")
        print("Cannot leave any question in error state with generic solutions")
        print("Examples of generic solutions to find and fix:")
        print("- 'Mathematical approach to solve this problem'")
        print("- 'Example answer based on the question pattern'")
        print("- 'Detailed solution for: [question]...'")
        print("- 'To be generated by LLM'")
        print("Admin credentials: sumedhprabhu18@gmail.com / admin2025")
        print("=" * 60)
        
        # First authenticate as admin
        admin_login = {
            "email": "sumedhprabhu18@gmail.com",
            "password": "admin2025"
        }
        
        success, response = self.run_test("Admin Login", "POST", "auth/login", 200, admin_login)
        if not success or 'access_token' not in response:
            print("‚ùå Cannot test LLM re-enrichment - admin login failed")
            return False
            
        self.admin_token = response['access_token']
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {self.admin_token}'
        }
        
        re_enrichment_results = {
            "admin_authentication": True,
            "database_scan_for_generic_solutions": False,
            "generic_solutions_identified": False,
            "llm_enrichment_pipeline_test": False,
            "force_re_enrichment_test": False,
            "solution_quality_verification": False,
            "database_update_verification": False,
            "student_experience_protection": False
        }
        
        # TEST 1: Database Scan for Generic Solutions
        print("\nüîç TEST 1: DATABASE SCAN FOR GENERIC SOLUTIONS")
        print("-" * 40)
        print("Scanning all questions in database for generic/wrong solutions")
        
        success, response = self.run_test("Get All Questions for Generic Solution Scan", "GET", "questions?limit=300", 200, None, headers)
        if success:
            questions = response.get('questions', [])
            print(f"   ‚úÖ Retrieved {len(questions)} questions from database")
            re_enrichment_results["database_scan_for_generic_solutions"] = True
            
            # Define generic solution patterns to identify
            generic_patterns = [
                "mathematical approach to solve this problem",
                "example answer based on the question pattern",
                "detailed solution for:",
                "to be generated by llm",
                "approach to solve this problem",
                "solution based on the question pattern",
                "mathematical solution approach",
                "step-by-step solution approach"
            ]
            
            generic_questions = []
            wrong_solution_questions = []
            
            for q in questions:
                question_id = q.get('id')
                stem = (q.get('stem') or '').lower()
                answer = (q.get('answer') or '').lower()
                solution_approach = (q.get('solution_approach') or '').lower()
                detailed_solution = (q.get('detailed_solution') or '').lower()
                
                # Check for generic solutions
                is_generic = False
                for pattern in generic_patterns:
                    if (pattern in solution_approach or 
                        pattern in detailed_solution or 
                        pattern in answer):
                        is_generic = True
                        break
                
                if is_generic:
                    generic_questions.append({
                        'id': question_id,
                        'stem': q.get('stem', '')[:80] + '...',
                        'answer': q.get('answer', '')[:50] + '...',
                        'solution_approach': q.get('solution_approach', '')[:80] + '...',
                        'detailed_solution': q.get('detailed_solution', '')[:80] + '...'
                    })
                
                # Check for solution mismatches (e.g., salary question with alloy solution)
                if 'earn' in stem or 'salary' in stem or 'income' in stem:
                    if ('alloy' in solution_approach or 'copper' in solution_approach or 
                        'aluminum' in solution_approach or 'metal' in solution_approach):
                        wrong_solution_questions.append({
                            'id': question_id,
                            'stem': q.get('stem', '')[:80] + '...',
                            'solution_approach': q.get('solution_approach', '')[:80] + '...',
                            'mismatch_type': 'salary_question_with_alloy_solution'
                        })
            
            print(f"   üö® FOUND {len(generic_questions)} questions with GENERIC solutions")
            print(f"   üö® FOUND {len(wrong_solution_questions)} questions with WRONG solutions")
            
            if len(generic_questions) > 0 or len(wrong_solution_questions) > 0:
                re_enrichment_results["generic_solutions_identified"] = True
                
                print("\n   üìã GENERIC SOLUTION EXAMPLES:")
                for i, q in enumerate(generic_questions[:5]):
                    print(f"     {i+1}. ID: {q['id']}")
                    print(f"        Question: {q['stem']}")
                    print(f"        Generic Solution: {q['solution_approach']}")
                    print()
                
                if wrong_solution_questions:
                    print("   üìã WRONG SOLUTION EXAMPLES:")
                    for i, q in enumerate(wrong_solution_questions[:3]):
                        print(f"     {i+1}. ID: {q['id']}")
                        print(f"        Question: {q['stem']}")
                        print(f"        Wrong Solution: {q['solution_approach']}")
                        print(f"        Mismatch Type: {q['mismatch_type']}")
                        print()
            else:
                print("   ‚úÖ No generic or wrong solutions found in database")
                re_enrichment_results["solution_quality_verification"] = True
        else:
            print("   ‚ùå Failed to retrieve questions from database")
            return False
        
        # TEST 2: LLM Enrichment Pipeline Test
        print("\nü§ñ TEST 2: LLM ENRICHMENT PIPELINE TEST")
        print("-" * 40)
        print("Testing if LLM enrichment pipeline generates proper solutions")
        
        # Create a test question to verify LLM enrichment works correctly
        test_question_data = {
            "stem": "RE-ENRICHMENT TEST: A person earns 30% more than his colleague. If the colleague earns Rs. 2000, how much does the person earn?",
            "hint_category": "Arithmetic",
            "hint_subcategory": "Percentages",
            "source": "Re-enrichment Test"
        }
        
        success, response = self.run_test("Create Test Question for LLM Pipeline", "POST", "questions", 200, test_question_data, headers)
        if success and 'question_id' in response:
            test_question_id = response['question_id']
            print(f"   ‚úÖ Test question created: {test_question_id}")
            print(f"   Status: {response.get('status')}")
            
            # Wait for LLM processing
            print("   ‚è≥ Waiting 15 seconds for LLM enrichment...")
            time.sleep(15)
            
            # Check if LLM generated proper solution
            success, response = self.run_test("Check LLM Pipeline Results", "GET", f"questions?limit=50", 200, None, headers)
            if success:
                questions = response.get('questions', [])
                test_question = None
                
                for q in questions:
                    if q.get('id') == test_question_id:
                        test_question = q
                        break
                
                if test_question:
                    answer = test_question.get('answer', '')
                    solution_approach = test_question.get('solution_approach', '')
                    detailed_solution = test_question.get('detailed_solution', '')
                    
                    print(f"   Generated Answer: {answer}")
                    print(f"   Generated Solution Approach: {solution_approach}")
                    print(f"   Generated Detailed Solution: {detailed_solution[:100]}...")
                    
                    # Check if solution is relevant and not generic
                    is_relevant = False
                    is_not_generic = True
                    
                    if answer and answer != "To be generated by LLM":
                        # Check for relevant content (should mention percentage, earning, 2600, etc.)
                        if ('2600' in str(answer) or '30%' in solution_approach or 
                            'percentage' in solution_approach.lower() or 
                            'earn' in solution_approach.lower()):
                            is_relevant = True
                    
                    # Check it's not generic
                    for pattern in generic_patterns:
                        if pattern in solution_approach.lower() or pattern in detailed_solution.lower():
                            is_not_generic = False
                            break
                    
                    if is_relevant and is_not_generic:
                        print("   ‚úÖ LLM enrichment pipeline working correctly")
                        print("   ‚úÖ Generated relevant, non-generic solution")
                        re_enrichment_results["llm_enrichment_pipeline_test"] = True
                    else:
                        print("   ‚ùå LLM enrichment pipeline issues detected")
                        if not is_relevant:
                            print("   ‚ùå Solution not relevant to question")
                        if not is_not_generic:
                            print("   ‚ùå Solution is still generic")
                else:
                    print("   ‚ùå Test question not found after creation")
        else:
            print("   ‚ùå Failed to create test question for LLM pipeline test")
        
        # TEST 3: CRITICAL - Use Mass Re-enrichment API Endpoint
        print("\nüîÑ TEST 3: CRITICAL MASS RE-ENRICHMENT API ENDPOINT")
        print("-" * 40)
        print("Using /api/admin/re-enrich-all-questions endpoint to fix ALL generic solutions")
        
        if len(generic_questions) > 0:
            print(f"   üö® CRITICAL: Found {len(generic_questions)} questions with generic solutions")
            print("   üîÑ Calling mass re-enrichment API endpoint...")
            
            # Call the critical re-enrichment endpoint
            success, response = self.run_test("Mass Re-enrichment API Call", "POST", "admin/re-enrich-all-questions", 200, {}, headers)
            if success:
                processed = response.get('processed', 0)
                success_count = response.get('success', 0)
                failed_count = response.get('failed', 0)
                status = response.get('status', 'unknown')
                
                print(f"   ‚úÖ Mass re-enrichment API called successfully")
                print(f"   üìä Status: {status}")
                print(f"   üìä Questions processed: {processed}")
                print(f"   üìä Successfully re-enriched: {success_count}")
                print(f"   üìä Failed to re-enrich: {failed_count}")
                
                if success_count > 0:
                    re_enrichment_results["force_re_enrichment_test"] = True
                    print(f"   üéâ SUCCESS: {success_count} questions re-enriched with proper solutions!")
                    
                    # Wait for processing to complete
                    print("   ‚è≥ Waiting 30 seconds for mass re-enrichment to complete...")
                    time.sleep(30)
                else:
                    print(f"   ‚ö†Ô∏è WARNING: No questions were successfully re-enriched")
                    if failed_count > 0:
                        print(f"   ‚ùå {failed_count} questions failed re-enrichment")
            else:
                print("   ‚ùå CRITICAL FAILURE: Mass re-enrichment API call failed")
                print("   üö® This is a production-blocking issue!")
        else:
            print("   ‚úÖ No generic questions found - database already clean")
            re_enrichment_results["force_re_enrichment_test"] = True
        
        # TEST 4: Database Update Verification
        print("\n‚úÖ TEST 4: DATABASE UPDATE VERIFICATION")
        print("-" * 40)
        print("Verifying that re-enrichment updated the database correctly")
        
        # Re-scan database for generic solutions
        success, response = self.run_test("Re-scan Database After Re-enrichment", "GET", "questions?limit=300", 200, None, headers)
        if success:
            questions_after = response.get('questions', [])
            print(f"   ‚úÖ Retrieved {len(questions_after)} questions after re-enrichment")
            
            # Count generic solutions again
            generic_count_after = 0
            for q in questions_after:
                solution_approach = (q.get('solution_approach') or '').lower()
                detailed_solution = (q.get('detailed_solution') or '').lower()
                answer = (q.get('answer') or '').lower()
                
                for pattern in generic_patterns:
                    if (pattern in solution_approach or 
                        pattern in detailed_solution or 
                        pattern in answer):
                        generic_count_after += 1
                        break
            
            original_generic_count = len(generic_questions)
            print(f"   üìä Generic solutions before: {original_generic_count}")
            print(f"   üìä Generic solutions after: {generic_count_after}")
            
            if generic_count_after < original_generic_count:
                print("   ‚úÖ Database update successful - generic solutions reduced")
                re_enrichment_results["database_update_verification"] = True
            elif generic_count_after == 0:
                print("   üéâ PERFECT! No generic solutions remaining in database")
                re_enrichment_results["database_update_verification"] = True
                re_enrichment_results["student_experience_protection"] = True
            else:
                print("   ‚ö†Ô∏è Generic solutions still present - may need more time or manual intervention")
        else:
            print("   ‚ùå Failed to verify database updates")
        
        # TEST 5: Student Experience Protection Verification
        print("\nüë®‚Äçüéì TEST 5: STUDENT EXPERIENCE PROTECTION")
        print("-" * 40)
        print("Verifying students won't see generic/wrong solutions")
        
        # Test session creation and question retrieval to ensure students get proper solutions
        student_login = {
            "email": "student@catprep.com",
            "password": "student123"
        }
        
        success, response = self.run_test("Student Login for Experience Test", "POST", "auth/login", 200, student_login)
        if success and 'access_token' in response:
            student_token = response['access_token']
            student_headers = {
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {student_token}'
            }
            
            # Create a session to test student experience
            session_data = {"target_minutes": 30}
            success, response = self.run_test("Create Student Session", "POST", "sessions/start", 200, session_data, student_headers)
            if success and 'session_id' in response:
                session_id = response['session_id']
                print(f"   ‚úÖ Student session created: {session_id}")
                
                # Get a question from the session
                success, response = self.run_test("Get Student Question", "GET", f"sessions/{session_id}/next-question", 200, None, student_headers)
                if success and 'question' in response:
                    question = response['question']
                    question_stem = question.get('stem', '')
                    
                    print(f"   ‚úÖ Student question retrieved")
                    print(f"   Question: {question_stem[:60]}...")
                    
                    # Submit an answer to get solution feedback
                    answer_data = {
                        "question_id": question['id'],
                        "user_answer": "test_answer",
                        "time_sec": 30,
                        "hint_used": False
                    }
                    
                    success, response = self.run_test("Submit Answer for Solution", "POST", f"sessions/{session_id}/submit-answer", 200, answer_data, student_headers)
                    if success and 'solution_feedback' in response:
                        solution_feedback = response['solution_feedback']
                        solution_approach = solution_feedback.get('solution_approach', '').lower()
                        detailed_solution = solution_feedback.get('detailed_solution', '').lower()
                        
                        print(f"   Solution shown to student: {solution_approach[:80]}...")
                        
                        # Check if student sees generic solution
                        student_sees_generic = False
                        for pattern in generic_patterns:
                            if pattern in solution_approach or pattern in detailed_solution:
                                student_sees_generic = True
                                break
                        
                        if not student_sees_generic:
                            print("   ‚úÖ Student protected - no generic solutions shown")
                            re_enrichment_results["student_experience_protection"] = True
                        else:
                            print("   ‚ùå CRITICAL: Student still seeing generic solutions!")
                    else:
                        print("   ‚ö†Ô∏è Could not verify solution feedback to student")
                else:
                    print("   ‚ö†Ô∏è No questions available in student session")
            else:
                print("   ‚ùå Failed to create student session")
        else:
            print("   ‚ùå Failed to login as student")
        
        # FINAL RESULTS SUMMARY
        print("\n" + "=" * 60)
        print("CRITICAL LLM SOLUTION RE-ENRICHMENT RESULTS")
        print("=" * 60)
        
        passed_tests = sum(re_enrichment_results.values())
        total_tests = len(re_enrichment_results)
        success_rate = (passed_tests / total_tests) * 100
        
        for test_name, result in re_enrichment_results.items():
            status = "‚úÖ PASS" if result else "‚ùå FAIL"
            print(f"{test_name.replace('_', ' ').title():<40} {status}")
            
        print("-" * 60)
        print(f"Overall Success Rate: {passed_tests}/{total_tests} ({success_rate:.1f}%)")
        
        # Critical analysis
        if re_enrichment_results["generic_solutions_identified"]:
            if re_enrichment_results["database_update_verification"]:
                print("üéâ CRITICAL SUCCESS: Generic solutions identified and fixed!")
                print("   ‚úÖ Database updated with proper solutions")
            else:
                print("‚ùå CRITICAL ISSUE: Generic solutions found but not fixed!")
                print("   üö® URGENT: Manual intervention required")
        else:
            print("‚úÖ EXCELLENT: No generic solutions found in database")
        
        if re_enrichment_results["student_experience_protection"]:
            print("‚úÖ STUDENT SAFETY: Students protected from generic solutions")
        else:
            print("‚ùå STUDENT RISK: Students may still see generic solutions")
        
        if success_rate >= 80:
            print("üéâ LLM SOLUTION RE-ENRICHMENT SUCCESSFUL!")
            print("   ‚úÖ Database cleaned, students protected")
        elif success_rate >= 60:
            print("‚ö†Ô∏è Re-enrichment mostly successful with minor issues")
        else:
            print("‚ùå CRITICAL FAILURE: Re-enrichment process needs immediate attention")
            
        return success_rate >= 70

def main():
    """Main test execution"""
    print("üöÄ STARTING CRITICAL LLM SOLUTION RE-ENRICHMENT TESTING")
    print("=" * 60)
    
    tester = CATBackendTester()
    
    # Run the critical re-enrichment test
    success = tester.test_critical_llm_solution_re_enrichment()
    
    print("\n" + "=" * 60)
    print("FINAL TEST SUMMARY")
    print("=" * 60)
    
    if success:
        print("‚úÖ CRITICAL LLM SOLUTION RE-ENRICHMENT: SUCCESSFUL")
        print("   Database cleaned of generic solutions")
        print("   Students protected from misleading content")
        print("   LLM enrichment pipeline operational")
    else:
        print("‚ùå CRITICAL LLM SOLUTION RE-ENRICHMENT: FAILED")
        print("   üö® URGENT ACTION REQUIRED")
        print("   Generic solutions may still exist")
        print("   Student experience at risk")
    
    return success

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)